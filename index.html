<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="IlluminatedWorm&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IlluminatedWorm&#39;s Blog">
<meta property="article:author" content="IlluminatedWorm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>IlluminatedWorm's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">IlluminatedWorm's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IlluminatedWorm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/illuminatedworm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;illuminatedworm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:609210163@qq.com" title="E-Mail → mailto:609210163@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/20/JSR-133%EF%BC%8Cvolatile%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/JSR-133%EF%BC%8Cvolatile%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">JSR-133，volatile，单例模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 15:23:57" itemprop="dateCreated datePublished" datetime="2020-11-20T15:23:57+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:17:43" itemprop="dateModified" datetime="2020-12-04T00:17:43+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>JSR-133 FAQ：<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html#dcl" target="_blank" rel="noopener">见此</a></p>
<p>Java Volatile Keyword：<a href="http://tutorials.jenkov.com/java-concurrency/volatile.html" target="_blank" rel="noopener">见此</a></p>
<p>如果你不想看整篇JSR-133，可以把它的FAQ当作原文的“太长不看版”来看。</p>
<h2 id="volatile，到底是什么？"><a href="#volatile，到底是什么？" class="headerlink" title="volatile，到底是什么？"></a>volatile，到底是什么？</h2><p>随意地在网上进行一些搜索，可以看到一些关于<code>volatile</code>关键词的解释：“可见性”，“原子性”，“防止指令重排”等等，还有一些摘录自经典书籍《Java并发编程实战》的总结。无论你能否能通过这些理解<code>volatile</code>关键词……总之，有一些原因促使我自己的本篇博客产生。</p>
<p>在一切之前，先来明确一些有助于理解的基本事实：</p>
<ul>
<li><code>volatile</code>有着一段历史：这是一个传承自C/C++的关键词，在C/C++中，这个关键词的含义只有类似Java中防止指令重排的作用——防止编译器优化被其修饰的变量，因为一个变量即使在此处看起来可以被优化，它仍然可能在别的什么地方被改变，如果编译器照常进行优化，程序就可能出错。然而由于Java内存模型的特殊性，<code>volatile</code>关键词在Java中后来还被新增了一些内存语义。</li>
<li><code>volatile</code>关键词在实践中并不那么重要，首先它的效果十分地有局限性和并非全然无害，其次并发编程经过多年的发展，我们已经有更好的理念和实践来处理曾经<code>volatile</code>所面对的问题。理解它更多地是理论解读的意义。</li>
<li>需要一些Java内存模型的前置知识来理解<code>volatile</code>。</li>
</ul>
<h3 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h3><img src="/2020/11/20/JSR-133%EF%BC%8Cvolatile%EF%BC%8C%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/jmm.png" class="">
<p>线程可能运行在不同的CPU里，而变量存放在主内存中，出于性能考虑，变量可能会被复制到CPU缓存中进行操作（注意，这里说的是Java内存模型而不是硬件层面的）。</p>
<p>关键在于，CPU缓存和主内存间的变量复制究竟何时发生，是并不确定的。CPU缓存1和CPU缓存2以未知顺序分别从主内存中复制变量，线程1和线程2分别对变量进行操作后，CPU缓存1和CPU缓存2中的可能改变的变量又以未知顺序分别复制回主内存，这一系列事件从<em>某种</em>角度来看，可以诠释为线程1与线程2之间不知道对方做了什么，此即线程间的不可见性。</p>
<p>“可见性”这个词更像是被提出来避免谈及Java内存模型才用的，可是它有点抽象。其实经此番了解，很自然地会发现这就是典型的缓存不一致性问题，这在普遍综合运用Redis和关系型数据库的今天，真是再日常不过的问题了。</p>
<h2 id="曾经存在过的问题"><a href="#曾经存在过的问题" class="headerlink" title="曾经存在过的问题"></a>曾经存在过的问题</h2><p>所以，究竟有什么问题，导致了Java内存模型和<code>volatile</code>语义的变动？来看一个非常熟悉的例子，双检查锁定单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你熟悉这种做法而且敏锐，就会意识到，这样写不正确，成员变量<code>instance</code>缺少<code>volatile</code>修饰符。但请注意，从一开始，DSL就是这样的，并没有人强调变量需要如何被修饰，这种看似聪明的做法会出错（然而话说回来，谁又会为了四句代码去认真地了解Java模型的问题呢？）。</p>
<p>为什么会出错？因为一个线程在第一个非空判断处可能读取到另一个线程创建到一半的<code>instance</code>对象，这个未完成的对象并非<code>null</code>，所以检测通过，此对象被返回。这非常地反直觉，我们可能从未料想到Java竟然不能判断一个对象是否“完整”，还将它从主内存同步到CPU缓存，最终因此出错（你可能会进一步地好奇在其他语言中又会怎么样，由于这是一个历史问题，只便于与C/C++这种“原生语言”进行比较，在它们的情况里，事情更复杂——结果依赖于类库，编译器和具体的运行平台）。</p>
<h2 id="volatile如何修复问题"><a href="#volatile如何修复问题" class="headerlink" title="volatile如何修复问题"></a>volatile如何修复问题</h2><p>关于<code>volatile</code>关键词，其内存语义的核心意义是：<strong>被修饰的变量存储在主内存中</strong>。具体地说：</p>
<ul>
<li>任何一次对<code>volatile</code>变量的读取，都从主内存中读取；</li>
<li>任何一次对<code>volatile</code>变量的写入，都写入主内存中；</li>
<li>这些读取和写入将会被同步（说人话就是依序逐一执行）。</li>
</ul>
<p>再从“可见性”的角度来审视一下新规定下的情况：任何线程都将看得见对<code>volatile</code>变量的最后一次写入。此即<code>volatile</code>对可见性的保证。好了，问题被解决了，只要以<code>volatile</code>修饰上例的<code>instance</code>变量，代码就能如预期般正常执行（顺便一提，无论是静态内部类占位符写法还是再后来的枚举写法，显然都比双重检查锁定写法只好不差，更健壮可靠，更清晰易读）。</p>
<h2 id="volatile为什么在实践中不那么重要"><a href="#volatile为什么在实践中不那么重要" class="headerlink" title="volatile为什么在实践中不那么重要"></a>volatile为什么在实践中不那么重要</h2><p>前文已经解释了前言铺垫中的大部分命题，接下来的内容对于<code>volatile</code>关键词来说有一些负面。</p>
<p>我个人不赞成在<code>volatile</code>的辨析中提及“原子性”，即便严格地看，它的确保证了原子性，只不过是对于上面提及的读取和写入这俩“单条指令”而言，可以想见读取和写入操作在底层的运行需要不止一条机器码。这一系列机器码的执行得到了原子性保证的事实，对于使用高级编程语言的程序员而言，有多少意义可言呢？我们所写的每一行代码都代表着许多机器码，从高级编程语言的角度来看，所谓<code>volatile</code>的原子性几乎就和任何一行代码般没有特别之处。</p>
<p>并且因为程序员更常接触的原子性概念是数据库事务那样的，对于<code>volatile</code>非常容易产生误解。对于<code>i += 1</code>这样简单的代码，如果你考虑<code>volatile</code>的“原子性”，可能会阶段性地经历以下“坑”：</p>
<ol>
<li>忽视这个代码是复合操作，代表着三个不同的操作：读取变量，修改，写回变量；</li>
<li>以为<code>volatile</code>能保证上述复合操作的原子性（不，它不能）；</li>
<li>如果<code>i</code>是引用类型，<code>+= 1</code>换作会改变其内部状态的方法，遗忘并忽略任何关于原子性的事情。</li>
</ol>
<p>第一、二点加起来再引申一下，就是到处都可见的用<code>volatile</code>变量写多线程读写计数器的反面教材用例（同样因为太常见所以不给出代码），<code>volatile</code>变量的作用实在是太有限了，只靠它，甚至连这样一个简单的程序都搞不定（严格地说，只用<code>volatile</code>是可以写出同样效果的正确程序，但是那也太复杂且没有必要了）。</p>
<p>位于java.util.concurrent.atomic包中的各种原子类，它们基于底层系统原语的CAS实现，除了具有和<code>volatile</code>变量相同的内存语义，还支持原子性的复合操作，用<code>AtomicInteger</code>来实现上面提到的计数器，将兼具简单，安全和高性能的优势。在多数情况下，这些原子类都是<code>volatile</code>变量的更佳版本（同样，多数情况下，原子类也比悲观锁高效，并且针对常见的ABA问题，JDK也提供了带版本号的原子类作为解决方案）。</p>
<p>联系之前介绍的内容，就会发现，只有当单个线程对某个变量写，而其他线程只对这个变量读时，只靠<code>volatile</code>就可以使一切正确。而这样的情况在实践中可以说是很狭隘了，哪怕只稍微复杂一点的情况，就需要额外的处理。并且<code>volatile</code>并不是全然无害的，CPU缓存的意义在于提升性能，而强行将一个变量存储在主内存是有一些性能问题，但硬件的进步使得<code>volatile</code>变量相比普通变量的额外代价完全不值一提。<code>volatile</code>变量对性能的潜在影响来自它妨碍指令重排的性质，众所周知的是，JIT编译器会对字节码进行优化，而出乎许多人意料的是，这种优化可能<strong>非常激进</strong>，只要编译器认为优化形式的最终运行结果与原本的串行运行结果一致，那几乎便认为一切都是被允许的，而<code>volatile</code>变量可能使你失去某些优化。</p>
<p><code>final</code>，<code>synchronized</code>和反射等也会妨碍指令重排，而它们仍然随处可见。提及这些是想强调，我要声明的只是<code>volatile</code><strong>并非没有代价</strong>，而不是赞成<strong>因噎废食</strong>，不要特别在意这些底层细节，该用就用。</p>
<h3 id="一点牢骚"><a href="#一点牢骚" class="headerlink" title="一点牢骚"></a>一点牢骚</h3><p>还有，一些人不屑于提及的是，<code>volatile</code>确实有一些学习成本，这是很现实的困难，很多关于<code>volatile</code>的解释不是很直接明白，初学者在资料查找中很可能陷入更多麻烦中，初学者背负着“可见性”，“原子性”之类一知半解的概念而来，收获了更多更难的概念。对此，JLS的指导作用可以说“功不可没”，JLS在<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.1" target="_blank" rel="noopener">§17.4</a>中定义了Java内存模型中的“数据竞争（data race）”，并声明<code>volatile</code>可以解决数据竞争，而且这个声明被很多二手资料提及，并引申地谈到“竞态条件（race condition）”，而JLS中并没有提过“竞态条件”这个词，最接近的是在§17.4.3中的这个描述：</p>
<blockquote>
<p>If a program has no data races, then all executions of the program will appear to be sequentially consistent.</p>
<p>Sequential consistency and/or freedom from data races still allows errors arising from groups of operations that need to be perceived atomically and are not.</p>
<p>（如果一个程序不含数据竞争，那么该程序的所有执行应该是串行一致的。）</p>
<p>（串行一致性和/或免于数据争用的影响，仍会导致应为原子性的，却没有具备原子性的操作组合引发错误。）</p>
</blockquote>
<p>无论如何，JLS没有提及“竞态条件”一词。绝大多数人都声称数据竞争和竞态条件不是一回事，它们也不是彼此的子集，然而就我个人而言，我从未见过一个很好的Java实例能独立地区分二者。当你查阅维基百科，你会发现数据竞争没有独立的条目，它被写在<a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener">竞态条件的条目</a>里，并且可以看到这两句话：</p>
<blockquote>
<p>A data race is a type of race condition. </p>
<p>（数据竞争是竞态条件的一种类型。）</p>
<p>Not all regard data races as a subset of race conditions.</p>
<p>（并非所有人都认为数据竞争是竞态条件的子集。）</p>
</blockquote>
<p>不客气地说，是部分人咀嚼术语的固执造的孽。竞态条件这个概念的提出甚至早于集成电路被发明，而数据竞争很可能是（未考证，但未见过更早资料）编程语言和软件工程时代的新概念，却有人试图把它们放在一起再辨明区别，显然，效果很不好。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>再想想上一节提到的那种适合<code>volatile</code>关键词的情况，是否有些像是发布/订阅模式，那么实践中是怎么处理复杂的发布订阅模式的呢？通常，最基本的是，我们要借助队列（JVM内或中间件）。这正指向另一方面，在编程语言的发展中，针对并发编程出现了许多新的理念和实践，即便是《Java并发编程实战》这本有些年头的经典，也承认，解决并发编程中的各种问题的最佳手段，是让它们从一开始就不出现，同时此书也用了较多篇幅反复强调，书里提及的那些处理手段是有代价的，并且你应该永不忽略性能问题，使用了复杂的技术，最终却编写出比等价同步程序还缓慢的并发程序可不是少数人犯的笑话（想想Redis社区的谨慎态度吧，在多个分支实践了多线程IO和经过漫长的辩论后，才在6.0版本推出了多线程IO以提升性能）。</p>
<p>例如像共享变量这个基础要求，你应该考虑这个变量是不是真的必须要同步，否则，将它封闭到线程中可能是更好的主意（<code>ThreadLocal</code>类）。甚至某些语言在这一点上施行得更加极端，例如，强调<code>final</code>变量，以线程封闭变量为常态。在Go这样受到Actor模型影响的语言里，共享变量是更有意而为的，经过某些显式的调用才能在线程间共享变量是常态。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/inline%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/inline%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" class="post-title-link" itemprop="url">inline的二三事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 19:38:08" itemprop="dateCreated datePublished" datetime="2020-11-09T19:38:08+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:17:35" itemprop="dateModified" datetime="2020-12-04T00:17:35+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>本文涉及关键词<code>inline</code>，<code>noinline</code>，<code>crossinline</code>，还会顺便提一下Lambda表达式里的返回值和<code>reified</code>。</p>
<p>对于内联，其中<code>noinline</code>和<code>crossinline</code>两个关键词，即使你不知就里，在IDE的提示下仍可以正确使用。</p>
<h2 id="为什么有inline"><a href="#为什么有inline" class="headerlink" title="为什么有inline"></a>为什么有inline</h2><p>Kotlin的一大特点是主张使用高阶函数配合函数类型建立高可用的自定义结构进行编程，这样有助于控制流程高抽象化和提高代码复用。所谓的高阶函数是指以函数为参数或者返回值的函数（这个概念来自数学，如果你把求导和积分也看作函数，那么你会发现它们的参数和结果都可能是另一个函数）。</p>
<p>然而和Java一样，Kotlin中的函数实际上也不能作为参数传递，被传递的东西<strong>最终本质</strong>上是一个对象（“函数类型”不是“函数”，<code>mehtod()</code>和<code>(::method)()</code>在底层发生了不同的事）。那么这便引申出一个问题，对象的创建是有代价的，这份代价虽然小，但也绝非没有，如果一个高阶函数被频繁调用——例如在一个执行很多次的循环体里被调用——会怎么样呢？</p>
<p>是的，这可能导致大量的对象被创建，造成显著的性能问题。Kotlin需要提供一种简单且显著的解决方法，所以<code>inline</code>便诞生了。</p>
<p>如果具有C++背景将非常容易理解什么是内联（inline），这个词的核心表示是<strong><em>替换</em></strong>，你向编译器<strong>推荐</strong>用被内联物的内容代替被内联物。Java中没有内联（可能的内联只会发生在运行时JVM的自主优化，这对程序员是完全透明的），Java中最接近的是编译器对编译时常量的优化：如果一个字面量类型变量的值在编译时已知。那么对它的引用将会被替换为值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_APPLICATION_NAME = <span class="string">"project-user"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">List&lt;InstanceInfo&gt; instances = discoveryClient.getInstances(USER_APPLICATION_NAME);</span><br></pre></td></tr></table></figure>
<p>像这样的代码，编译器便会把<code>getInstances()</code>方法的参数从对<code>USER_APPLICATION_NAME</code>的引用替换为<code>&quot;project-user&quot;</code>。</p>
<p>这就是内联，只不过在Kotlin中的，编译器做的更多，它为你把函数调用替换成了被调用函数里的代码，并且做了一些保证最终效果一致性的工作（顺便一提，在Kotlin中调用内联函数时传入<code>++i</code>和<code>i++</code>这种参数不会产生C++的经典Bug）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, <span class="variable">$s</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在编译后大致是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, Kotlin"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, Kotlin"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, Kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, <span class="variable">$s</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是一个用于说明的简单例子，实际上如果真的这么做，IDE会提示你，这么做起不到优化作用，因此没有必要添加<code>inline</code>，它应该被用在函数参数有函数类型的情况下。这种提示的强烈暗示加上之前关于对象创建的代价问题（当然，你可以去看字节码来完全证实），已经可以摸到<code>inline</code>更主要的目的：把函数类型的参数也进行内联。没有什么参数传递了，也没有对象被创建了，直接跑原本的代码吧。</p>
<p>现在远非万事大吉，引入<code>inline</code>解决了一个问题，但又引发了另一些问题（喜闻乐见的环节）。即使在上面这个十分简单的说明用例里，你也可以发现代码变多了，内联函数会导致字节码膨胀，这不但会让最终打包的文件容量变大，还可能影响运行效率（毕竟，需要运行的代码变多了），违背<code>inline</code>被引入的初衷。所以IDE才会有那个提示，告知你只有高阶函数才适合内联化，其实这也并不足够，程序员应当小心掂量，只对频繁被调用的高阶函数进行内联化，但这劳累心智，某些情况下也不现实（如果你写的是类库，你怎么肯定使用者的用法？）。</p>
<h2 id="noinline？"><a href="#noinline？" class="headerlink" title="noinline？"></a>noinline？</h2><p>这个关键词字面意思看起来挺明白的，意思就是不要内联化，那怎么的又需要非内联化呢？</p>
<p>在上面已经说过，高阶函数能以函数作为返回值，而就像函数其实不能作为参数一样，函数其实也不能作为返回值，在Kotlin中返回函数也是返回了一个对象，这个函数类型的对象和函数并不是一个东西。</p>
<p>而编译器对内联化函数的函数类型的参数也执行了内联，现在没有什么函数类型了，只剩下最纯洁朴素的等价代码块，显然代码块不能被返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> aFunction = saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        println(<span class="string">"Hello, <span class="variable">$it</span>"</span>)</span><br><span class="line">        println(<span class="string">"I`m a inline function, <span class="variable">$it</span>"</span>)</span><br><span class="line">        println(<span class="string">"Goodbye, <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span>: (String) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    f(s)</span><br><span class="line">    <span class="keyword">return</span> f <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDE直接就提示了：</p>
<blockquote>
<p>Illegal usage of inline-parameter ‘f’ in ‘public inline fun saySth(s: String, f: (String) -&gt; Unit): Unit defined in root package in file main.kt’. Add ‘noinline’ modifier to the parameter declaration</p>
</blockquote>
<p>只要给参数<code>f: (String) -&gt; Unit</code>加上<code>noinline</code>前缀，就可以成功编译并运行了。如果你真的这么做，你会发现IDE又提示<code>inline</code>不被建议了，因为这个说明用例里只有一个函数类型的参数。显然<code>noinline</code>的使用场景是：在至少有两个函数类型的参数的内联化高阶函数中，需要返回某一个函数类型的参数，就给它加上<code>noinline</code>。不用记着，IDE和编译器会让你正确的。</p>
<h2 id="Kotlin的Lambda好像不能写return？"><a href="#Kotlin的Lambda好像不能写return？" class="headerlink" title="Kotlin的Lambda好像不能写return？"></a>Kotlin的Lambda好像不能写return？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSaySth</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""" // 错误</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            Goodbye,<span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"no thing to said."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    f(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(getSaySth())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这个代码，Lambda表达式中的<code>return</code>究竟返回到哪个函数？是<code>saySth()</code>还是<code>main()</code>，有点意味不明，而Kotlin选择不允许这么做（当然你可以使用带标签的<code>return@saySth</code>），你或许觉得同样的事情在Java中被允许而在Kotlin中重新规定有点可笑，但得记住，在Kotlin里Lambda表达式有更多玩法，例如在类型安全的构建器里出现<code>return</code>就明显不合适。在Kotlin中，Lambda表达式默认以最后一行代码为返回值。</p>
<p>但只要你见过的Kotlin代码够多，你或许见过能写<code>return</code>的Lambda表达式。是的，内联函数的函数类型参数就允许被写<code>return</code>，因为内联化破坏了被调用函数的作用域，联系第一小节的例子，你就能明白，Lambda表达式里的<code>return</code>已经很明白地指向<code>getSaySth()</code>了，对<code>saySth()</code>的调用已经消失了。</p>
<p>所以只要给<code>saySth()</code>加上<code>inline</code>修饰符，以上代码就能成功编译和运行，并输出“Hello……”的文本。</p>
<p>我认为这是Kotlin中过度设计的一点，虽然一切最终符合Kotlin的设计哲学（简单易用：你不需要知道一个高阶函数是否内联来判断是否可以在Lambda表达式中使用<code>return</code>，但只要能使用<code>return</code>你就知道这个函数是内联的），但内联化高阶函数的<code>return</code>被搞得如此复杂，在带标签的<code>return</code>存在的前提下，这真的有必要吗？</p>
<h2 id="crossinline又是怎么回事？"><a href="#crossinline又是怎么回事？" class="headerlink" title="crossinline又是怎么回事？"></a>crossinline又是怎么回事？</h2><p>记住关于Lambda表达式中<code>return</code>的问题，考虑以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        f(s) <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">"""</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            Goodbye,<span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">        println(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不能编译呢，IDE这样说：</p>
<blockquote>
<p>Can’t inline ‘f’ here: it may contain non-local returns. Add ‘crossinline’ modifier to parameter declaration ‘f’</p>
</blockquote>
<p>和<code>noinline</code>一样，你不需要搞明白为什么，依提示加上<code>crossinline</code>即可。但现在看提示再联系返回值的问题，你就会明白，对<code>f(s)</code>的调用并不是由<code>saySth()</code>发起的，甚至都不是在本线程被调用，它被交给了某个协程来调用。如果<code>f(s)</code>会返回，那返回到谁呢，显然上一小节提到的处理不适合这种情况，毕竟它都在别的协程里被调用了！并且你可以看到，在这个例子里<code>f</code>的返回值是<code>Unit</code>也不会例外。</p>
<p>所以就需要<code>crossinline</code>来允许和优化这种特别的调用（发现了吗，Kotlin能帮你完成不同线程间变量的安全传递，而至于我们，基本上什么也不用做）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, <span class="keyword">crossinline</span> f: (<span class="type">String</span>) -&gt; <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> f(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> str = saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I'm running in <span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">            Goodbye, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"main is running in <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果（想看见协程名需要加入JVM运行参数：-Dkotlinx.coroutines.debug）：</p>
<blockquote>
<p>main is running in main @coroutine#1<br>Hello, Kotlin<br>I`m a inline function, Kotlin<br>I’m running in DefaultDispatcher-worker-1 @coroutine#1<br>Goodbye, Kotlin</p>
</blockquote>
<h2 id="reified"><a href="#reified" class="headerlink" title="reified"></a>reified</h2><p>在Java中，一个运用反射和泛型获取实例的最简单方法大概是这的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你必须向当中传入一个<code>Class&lt;T&gt;</code>类型的对象。而在Kotlin中你可以这样做：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getInstance</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> T::<span class="class"><span class="keyword">class</span>.<span class="title">objectInstance</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin的泛型和Java一样进行了泛型擦除，<code>reified</code>这个关键词只能在内联函数中使用，这是一个很简单的语法糖，你不再需要自己传入那个<code>Class&lt;T&gt;</code>了，编译器代你做了类似的事情。现在可以对<code>T</code>使用Kotlin中的<code>is</code>和<code>as</code>，配合智能类型转换，还是多少能省一些事，并且在函数的使用者看来，效果更加，例如在Spring提供的Kotlin Bean DSL中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> beans = beans &#123;</span></span><br><span class="line">  bean&lt;UserHandler&gt;()</span><br><span class="line">  bean&lt;Routes&gt;()</span><br><span class="line">  bean&lt;WebHandler&gt;(<span class="string">"webHandler"</span>) &#123;</span><br><span class="line">    RouterFunctions.toWebHandler(</span><br><span class="line">      ref&lt;Routes&gt;().router(),</span><br><span class="line">      HandlerStrategies.builder().viewResolver(ref()).build()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bean&lt;UserHandler&gt;</code>意味着去查找<code>UserHandler</code>的构造器来创建Bean，而<code>ref&lt;Routes&gt;</code>相当于是<code>applicationContext.getBean(Routes::class.java)</code>。</p>
<p>奇怪的是用Kotlin写Spring Boot时，并不能自然地运用这种DSL来创建Bean。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Stream类实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-23 13:34:41" itemprop="dateCreated datePublished" datetime="2020-10-23T13:34:41+08:00">2020-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:18:04" itemprop="dateModified" datetime="2020-12-04T00:18:04+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>参考资料：《Java核心技术 卷二》，JDK8 API doc</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先看看<code>Stream</code>最重要的一点，执行顺序。示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeekThePeekMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;ValuePair&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">1</span>, <span class="string">"one"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">2</span>, <span class="string">"two"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">3</span>, <span class="string">"three"</span>));</span><br><span class="line">        list.stream()</span><br><span class="line">                .peek(valuePair -&gt; System.out.println(valuePair.getCode()))</span><br><span class="line">                .peek(valuePair -&gt; System.out.println(valuePair.getName()))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// constructors, toString, setter and getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>1<br>one<br>ValuePair{code=1, name=’one’}<br>2<br>two<br>ValuePair{code=2, name=’two’}<br>3<br>three<br>ValuePair{code=3, name=’three’}</p>
</blockquote>
<p>明显可以看出，stream并不是在每次操作时对包含的每个元素进行遍历，而是只进行了一次遍历，否则每次操作的结果会相邻。</p>
<p>也就是说，stream的操作等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list) &#123;</span><br><span class="line">    System.out.println(valuePair.getCode());</span><br><span class="line">    System.out.println(valuePair.getName());</span><br><span class="line">    System.out.println(valuePair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair.getCode());</span><br><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair.getName());</span><br><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair);</span><br></pre></td></tr></table></figure>
<p><code>Stream</code>和第一种for-each循环的效果符合人类思维的自然预想，剩下的那种显然不对。这里想表达的重点在于，<code>Stream</code>是如何将三个操作压缩到一起执行的呢？稍微想想就能发现，最简单直接的实现方式——转存数据结构，对每个操作方法以循环来实现——达成的效果是三个顺序执行的for-each循环那样的。</p>
<p>那么要达成预期效果，自然会想到一种方式：<strong>记录</strong>而非执行。将操作记录下来，最终统一执行。更本质地讲，就是将执行<strong>延迟</strong>，这就是为什么<code>Stream</code>类的方法接受的参数都是Lambda表达式（函数式接口），使用Lambda表达式的用意在某种程度上就是要让执行被推后。</p>
<p>我们完全可以想象（如果熟悉Java中Lambda表达式的实现方式的话，这里就不讲了invokedynamic，<code>MethodHanlder</code>，<code>CallSite</code>和内部类那些事儿了……），这些Lambda表达式都被记录在某个集合里，最终被拿出来遍历执行。</p>
<h2 id="对照例子"><a href="#对照例子" class="headerlink" title="对照例子"></a>对照例子</h2><p>另一个例子，作为后文的具象参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"cat"</span>);list.add(<span class="string">"dog"</span>);list.add(<span class="string">"pig"</span>);</span><br><span class="line">list.add(<span class="string">"olIve"</span>);list.add(<span class="string">"pinK"</span>);list.add(<span class="string">"silVer"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>).toLowerCase())</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>过程追踪：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/trace.png" class="">
<p>输出结果：</p>
<blockquote>
<p>Olive<br>Pink<br>Silver</p>
</blockquote>
<h2 id="如何记录？"><a href="#如何记录？" class="headerlink" title="如何记录？"></a>如何记录？</h2><p>一张<code>Stream</code>实现的继承关系图：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/overview.png" class="">
<p>这当中没有画出对<code>int</code>，<code>long</code>和<code>double</code>特化的类，<strong>但它们存在</strong>。它们的结构也基本为Stream &lt;- Pipleline &lt;- Head+StatefulOp+StatelessOp。因为Java的泛型并不支持原始类型，而使用包装类带来的打包和解包有性能损耗，因此具有这些特化的类。</p>
<h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><p>对示例代码进行追踪，可以发现<code>list.stream()</code>的作用是：</p>
<ol>
<li>获取<code>ArrayList</code>的<code>Spliterator</code>对象（简单地说，就是可并行化的<code>Iterator</code>）。</li>
<li>将该对象传入<code>ReferencePipeline.Head</code>构造器创建出<code>Head</code>对象。<code>new ReferencePipeline.Head&lt;&gt;(spliterator, StreamOpFlag.fromCharacteristics(spliterator), parallel);</code></li>
</ol>
<p>看看这个构造器的签名：<code>Head(Spliterator&lt;?&gt; source, int sourceFlags, boolean parallel)</code>。很简单易懂，<code>Spliterator</code>即数据源，parallel表示是否并行化，在这里为<code>false</code>，sourceFlags是由前文方法以数据源算得的特征值，从<code>StreamOpFlag</code>类的注释中可以知道，这是一个表示多项状态的<code>int</code>值（掩码）：</p>
<ul>
<li>DISTINCT 是否独特 （例如，<code>Set</code>是独特的，而<code>List</code>不是）</li>
<li>SORTED 是否排序（例如，<code>SortedSet</code>是排序的，而<code>ArrayList</code>不是）</li>
<li>ORDERED 是否有序（例如，<code>ArrayList</code>是有序的，而<code>HashMap</code>不是）</li>
<li>SIZED 已知或未知大小（<code>Stream</code>支持无限流）</li>
</ul>
<p>我们并不关心特征码的具体情况，我们只需要知道，<code>Stream</code>记录了这些信息，留待后用。</p>
<p>最终<code>Head</code>对象的实际创建落到<code>AbstractPipeline</code>的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                 <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.sourceSpliterator = source;</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">    <span class="comment">// The following is an optimization of:</span></span><br><span class="line">    <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">    <span class="keyword">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.parallel = parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的链表单元，包含着相关信息，并且是头——指向的前单元为<code>null</code>。</p>
<h3 id="身"><a href="#身" class="headerlink" title="身"></a>身</h3><p>追踪<code>filter()</code>方法，发现与头的处理类似，实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两层重写建立了一个具有定制的<code>opWrapSink()</code>方法的<code>StatelessOp</code>对象，该方法能返回一个定制的<code>Sink.ChainedReference</code>对象。<code>Sink</code>是扩展的<code>Cosumer</code>接口：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/sink_overview.png" class="">
<p>这些方法的目的大致如下：</p>
<ul>
<li><code>begin()</code>，最先触发，重置<code>Sink</code>状态以接受新数据。与流大小变化有关，这上面的例子中，传入参数-1表示后续流大小未知或无限。</li>
<li><code>accept()</code>，当前处理步骤。</li>
<li><code>cancellationRequested()</code>，表示该步骤不再接受任何数据。与短路/非短路操作有关。</li>
<li><code>end()</code>，最后触发，已接受完所有数据。与有状态/无状态操作有关。</li>
</ul>
<p>创建<code>StatelessOp</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加清晰了，能看出代码在制造双向链表。</p>
<p><code>StatefulOp</code>的相关代码更加复杂，就不展示出来撑爆这篇博客的长度了，总体思路和<code>statelessOp</code>是相同的，最大的区别是<code>StatefulOp</code>中的<code>end()</code>方法经过了复杂的重写，因为有状态的操作依赖上一次操作的结果，所以需要在<code>end()</code>中执行处理。</p>
<h3 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h3><p>结束方法并没有与之前的链表链接，而是从链表尾遍历到头，完成翻转的打包，再进行执行，对于<code>forEach()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用<code>forEach()</code>方法举例的原因就是相比其他结束方法相对简单……</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然<code>Stream</code>的使用非常直观简单，但其具体实现可以说很是令人头晕目眩，即使抛掉流那些用于检验判断的元信息和其传递过程来看，也得在繁多的多态关系间检索。</p>
<p>不得不承认针对面向对象编程抽象过度的批评是有道理的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/" class="post-title-link" itemprop="url">HashMap容量背后的争论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-11 19:34:06" itemprop="dateCreated datePublished" datetime="2020-10-11T19:34:06+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:17:25" itemprop="dateModified" datetime="2020-12-04T00:17:25+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<h2 id="HashMap的奇怪容量设置"><a href="#HashMap的奇怪容量设置" class="headerlink" title="HashMap的奇怪容量设置"></a>HashMap的奇怪容量设置</h2><p>在JDK的<code>HashMap</code>中，它的默认初始容量为16，用户输入的任何初始容量都会被计算为不小于输入的2的整数次幂，在实例发生扩容时也会保持容量为2的整数次幂。</p>
<p>这是一个比较奇怪的事实。经典书籍《算法导论》中关于散列表的章节是这么说的：</p>
<img src="/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/1.png" class="">
<p>《算法导论》认为，当采用除法散列法时，散列表的大小应该选取一个较大的，不接近2的整数次幂的质数，并且应该避免选择2的整数次幂。这个说法符合直觉，并且应该是对的，有许多衍生的分析，比如具体哪些数比较好（碰撞率低而本身又不是非常大）。</p>
<p>但JDK采用的实现，完全与之相悖，虽然官方并没有作出具体解释，但在<a href="https://docs.oracle.com/javase/tutorial/collections/implementations/set.html" target="_blank" rel="noopener">这个网页</a>里提到：</p>
<blockquote>
<p>In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. </p>
<p>（过去，选择质数作为初始容量有一些优势。现在不再如此。）</p>
</blockquote>
<h2 id="怎么回事？"><a href="#怎么回事？" class="headerlink" title="怎么回事？"></a>怎么回事？</h2><p>首先，矛盾存在的前提是，<code>HashMap</code>的散列方法也为除法散列法，然而查看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键在于<code>(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null</code>，其实看JDK 7的代码更加简单明白（因为JDK 8中<code>HashMap</code>获得了一些改进，主要是树化机制）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以JDK的散列方法是<code>h &amp; (length-1)</code>这样一个怪异的位运算，而不是取模。似乎这就是答案了：散列方法不同，没有什么矛盾。位运算更快，所以JDK的做法也可取。</p>
<p>网上不少分析看起来都是按照这个思路发生的，既然是新方法，那么就找出一些合理性，直接进入喜闻乐见的二进制环节，还能顺便把<code>hash()</code>方法为什么要对哈希值作位运算再与原值作异或运算讲了。</p>
<p>但很多分析都忽略了一个更直接的事实：<strong><em>当length为2的整数次幂时，hash &amp; (length - 1) = hash % length</em></strong>。并且因此<strong>混淆了<code>hash()</code>方法和散列方法的意图</strong>。即便这种做法作为一种tricky/hack的位运算技巧流传较广，但我才疏学浅不能解释背后的数学原理。</p>
<p>总之，JDK采用的散列方法本质仍然是除法散列法，而JDK做出的优化是用特定条件下的等价位运算来提升计算速度，<strong>这个优化并没有回避掉如此容量值产生的高碰撞率问题</strong>。根据<a href="http://blog.teamleadnet.com/2012/07/faster-division-and-modulo-operation.html" target="_blank" rel="noopener">这个博客</a>的说法，此优化提升巨大，高达10-20倍！我相信正是这样数量级的差异令JDK开发者做出了取舍。</p>
<p>那么JDK开发者又是怎么改善碰撞率的呢？这个的答案才在<code>hash()</code>方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，这里就不像其他分析一样写二进制示例了。hash ^ ( h &gt;&gt;&gt; 16)这个运算的目的用人话来说就是，<strong>将高位“融合进”低位，降低碰撞率</strong>，这包括俩方面：</p>
<ul>
<li>避免散列表容量较小的情况下（16位及以内，0 ~ 65535，显然，这是最常见的情况），运算时对散列值高位不敏感。</li>
<li>提高散列值低位分布方式的均匀程度。</li>
</ul>
<p>以上过程看待数字的角度在十进制和二进制之间切换而没有说明，因为这样写非常冗杂，但应该意识到这一点。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下：</p>
<ul>
<li><code>HashMap</code>取桶索引的算法大幅优化了运算速度，本质仍然是除法散列法，没有改善高碰撞率。</li>
<li>改善高碰撞率的是<code>hash()</code>方法，它将原散列值的高位“融合进”低位。</li>
</ul>
<p>所以，《算法导论》仍然是对的，直觉没有被违背。JDK的做法是基于原理论的取舍优化而不是全面舍弃——既保留位运算相对除法的巨大性能提升，又试图解决高碰撞率的问题。</p>
<p>计算机科学和数学关系莫大，却经常会在实践中超出数学的范畴，JDK的<code>HashMap</code>实现是一个例子，毕竟只从数学角度考虑，位运算和除法并没有什么区别，也不会有什么后续可言。类似的事情还在Dual-Pivot Quicksort这个经典排序算法里发生过，这个算法获得性能提升的关键在于计算机硬件而不是数学的算法分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">异步与同步，阻塞与非阻塞，并发与并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-01 22:04:05" itemprop="dateCreated datePublished" datetime="2020-10-01T22:04:05+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:18:35" itemprop="dateModified" datetime="2020-12-04T00:18:35+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>Kotlin协程实现细节：<a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#implementation-details" target="_blank" rel="noopener">见此</a></p>
<p>Dragonwell的Wisp2：<a href="https://github.com/alibaba/dragonwell8/wiki/Wisp%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">见此</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Java并发编程实战》，稍微整理一下基础知识。<br>这些术语是上下文相关的，也就是说具体取决于讨论范围和语境。这里只从Java并发编程的角度展开。</p>
<p>在Java中，线程生命周期如下：</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/Thread.png" class="">
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>相比标题里的前两者，并发和并行的区别更明显也更简单，所以第一个说。</p>
<p>借用名著《并发的艺术》的说法：</p>
<blockquote>
<p><em>A system is said to be</em> <em>concurrent</em> <em>if it can support two or more actions</em> <em>in progress</em> <em>at the same time. A system is said to be</em> <em>parallel</em> if it can support two or more actions executing simultaneously.</p>
<p>（如果某个系统支持两个或者多个动作同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。）</p>
</blockquote>
<p>区别在于“存在”和“执行”。</p>
<p>并发是指有多个线程都已经调用了<code>start()</code>，无论是在Java还是在其他领域，并发总是自然地被确保的，即使是在单核处理器的计算机上运行，多个线程也会交替地出入内存，也就是说，重点在于这些线程是同时存在的，仅此而已。</p>
<p>并行一定是指运行在多核处理器的计算机上的情况，多个线程被分配到不同的处理器内核上，真正的同时运行。</p>
<p>可以得出一些强化认识的推论：</p>
<ul>
<li>并行是并发的真子集（但在通常的语境下，并发所指的是不包含并行的那部分，应该意识到这一点。）。</li>
<li>对于单线程，这两个概念没有意义（Java程序肯定是多线程的——至少包括一个主线程和一个GC线程）。</li>
<li>在单核处理器的计算机上运行多线程程序一定是并发的。</li>
</ul>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>简单地说，阻塞与非阻塞就是关注线程是否会因某次操作而被挂起（等待，睡眠），而因为这几乎总是关乎系统调用，所以这对概念几乎总是与I/O一起被提及。之前已经说了本文只关注Java并发编程，不会讨论内核和底层的相关概念。</p>
<p>在<code>InputStream.read()</code>方法的文档中有这样的描述：</p>
<blockquote>
<p>Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.<br>If the length of b is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value -1 is returned; otherwise, at least one byte is read and stored into b. </p>
<p>从输入流中读入一些字节并将其存入缓冲数组b，实际读取的字节数将以整数形式返回。此方法将阻塞，直到输入数据可用，检测到文件末尾或某个异常被抛出。</p>
<p>如果b的长度为零，则没有字节（会）被读取，返回0；否则，试图读取至少一个字节。如果因流达到文件末尾导致无字节可用，返回值-1；否则，至少有一字节被读取并存入b。</p>
</blockquote>
<p>虽然非常不像是人话，但这已经说尽了阻塞：当发起<code>read()</code>方法调用，直到达成某些条件前，将没有可用的结果，不管这些条件是预料的正常读取还是别的情况。既然没有可用的结果，那么当前线程运行下去将是意味不明的，将其挂起是完全理所当然的做法。</p>
<p>而非阻塞是指，调用不会使得线程挂起，在定义上就是这么简单。</p>
<h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><p>再次声明，本文不会像许多同类讨论一样大谈内核和底层。在本文的讨论范围中，同步和阻塞完全是一回事，异步和非阻塞也是一回事。</p>
<p>但这样也导致本小节不会有什么真正可供鉴别的主题——<strong><em>抛掉硬件底层和操作系统层面的事情，所谓的异步与同步的差异，只是类库与框架呈现给程序员的表象</em></strong>。异步就是分离值的计算和获取，仅此而已。</p>
<p>本小节<strong>将通过JavaScript看异步编程</strong>，在Web编程中，因为AJAX的流行，从JavaScript中接触异步编程十分普遍。而Java的异步编程更多地见于JavaFX，Swing和数据分析等地方，相对地不是那么常见和便于举例。</p>
<p>许多Java程序员轻视JavaScript，以至于对<code>promise</code>对象所知甚少，但人人都见过这种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(f)</span><br><span class="line">.then(f1)</span><br><span class="line">.catch(e1)</span><br><span class="line">.then(f2)</span><br><span class="line">.catch(e2)</span><br></pre></td></tr></table></figure>
<p>它的抽象概念是，调用某个函数，如果它有成功的结果，调用f1，否则是失败的结果，调用e1，f1和e1又可能有成功和失败的结果，类似地，根据情况分别再调用f2和e2。</p>
<p>但运行在某个浏览器中的JavaScript的代码总是阻塞的，JavaScript中根本没有线程概念，但它实际就是单线程的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码永远依次输出1，2，3，4。“主线程”在输出3之后，才去执行了<code>setTimeout</code>函数（实际上，JDK中的<code>Timer</code>类也是这样的，真正的多线程定时任务需要<code>ScheduledThreadPoolExecutor</code>，原生定时任务的实现别再用<code>Timer</code>了）。</p>
<p>所以这种情况下这<strong><em>真的异步</em></strong>了吗？阻塞和非阻塞这对概念尚且关注的是一个对象的状态，但异步和同步关注的一定是至少两个对象间的关系，所以，不是，它要解决的是程序员心智层面的认知问题，而不是CPU或者操作系统的问题。</p>
<p>JavaScript的实践中，经常会出现这种情况：这个函数需要那个函数的回调，另一个函数又需要这个函数的回调，甚至那个函数又依赖第四个函数的回调……在<code>promise</code>成为JavaScript官方规范和出现在第三方类库中之前，名为回调地狱的现象困扰着前端程序员，以下是一个夸张而搞笑的示例：</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/callback_hell.jpeg" class="">
<p>这样的代码看起来令人眼疼头疼，难以维护。现在的JavaScript，可以把这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">nextStep</span> =&gt;</span> &#123;</span><br><span class="line">  getBeef(<span class="function"><span class="keyword">function</span> (<span class="params">beef</span>) </span>&#123;</span><br><span class="line">    cookBeef(beef, <span class="function"><span class="keyword">function</span> (<span class="params">cookedBeef</span>) </span>&#123;</span><br><span class="line">      getBuns(<span class="function"><span class="keyword">function</span> (<span class="params">buns</span>) </span>&#123;</span><br><span class="line">        putBeefBetweenBuns(buns, beef, <span class="function"><span class="keyword">function</span>(<span class="params">burger</span>) </span>&#123;</span><br><span class="line">          nextStep(burger)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeBurger(<span class="function"><span class="keyword">function</span> (<span class="params">burger</span>) =&gt; </span>&#123;</span><br><span class="line">  serve(burger)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>变成这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(<span class="function"><span class="params">beef</span> =&gt;</span> cookBeef(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">cookedBeef</span> =&gt;</span> getBuns(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">bunsAndBeef</span> =&gt;</span> putBeefBetweenBuns(bunsAndBeef));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(<span class="function"><span class="params">burger</span> =&gt;</span> serve(burger));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用单参数函数的优势省略箭头函数的形式:</span></span><br><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(cookBeef)</span><br><span class="line">    .then(getBuns)</span><br><span class="line">    .then(putBeefBetweenBuns);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>甚至是这样的（ES6的generator也可以做到，在此不举例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beef = <span class="keyword">await</span> getBeef();</span><br><span class="line">  <span class="keyword">const</span> cookedBeef = <span class="keyword">await</span> cookBeef(beef);</span><br><span class="line">  <span class="keyword">const</span> buns = <span class="keyword">await</span> getBuns();</span><br><span class="line">  <span class="keyword">const</span> burger = <span class="keyword">await</span> putBeefBetweenBuns(cookedBeef, buns);</span><br><span class="line">  <span class="keyword">return</span> burger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>虽然每一行代码对应的具体<code>promise</code>对象的实现还是要落到程序员自己头上（所以还是那句话，没有什么魔法），但最终呈现的效果确实更清晰易读了，把有问题的实现方式换了一种实现方式（麻烦程度究竟有没有降低很难说，前端程序员中也有其他声音）。</p>
<p>JDK中也有着<code>promise</code>的等价物，即<code>CompletableFuture&lt;T&gt;</code>类（当然，还是<code>Future&lt;T&gt;</code>用得更多），最本质的不同还是在于多线程，此类下的某些方法允许程序员将任务交给其他线程执行。另外，<code>Collection</code>接口和<code>BaseStream</code>接口中分别提供了<code>parallelStream()</code>和<code>parallel()</code>方法，可以很方便地把原本的数据源并行化（这个说法是由方法名而来的，其实参考第一小节的结论，说是并发化更严谨），最终效果类似<code>async</code>和<code>await</code>关键词：写的是同步代码，执行却不是。而达成这种效果似乎是目前异步编程的主要趋势。</p>
<h3 id="协程，纤程，Project-Loom"><a href="#协程，纤程，Project-Loom" class="headerlink" title="协程，纤程，Project Loom"></a>协程，纤程，Project Loom</h3><p>协程/纤程（coroutine/fiber），同样的，这两个东西都是较基础的概念，具体实现有多种。另外，我们应当把协程看成是线程的补充，或者更直白地讲，是一层更友好的封装，而不是完全代替品。</p>
<p>就JVM语言来说，Kotlin中已经有了协程，然而Kotlin/JVM中的实现方式可能有待时间考验，Kotlin用有限状态机控制的线程池实现协程，在Kotlin的实现方式中并不存在运行时协程，而是和许多其他的Java协程库一样，只能说是字节码级的。并且因为Project Loom的存在，可以预见，Kotlin协程在Android有着必要而稳固的地位，而在JVM上就显得有些前途未卜。</p>
<p>Loom是一个正在进行的纤程（协程Coroutine和纤程Fiber在本文讨论的语境中基本同义）类库，目标是在JVM层面建立<strong>轻量级虚拟线程</strong>，以解决Java线程过于沉重而不够灵便的问题——与内核线程一比一相关，联系太紧密。</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/fiber.png" class="">
<p>Loom与Goroutine的主要是区别，Loom是有栈协程，Goroutine是无栈协程（说Goroutine是协程其实有一点小问题），可以简单地认为前者有功能和兼容性的优势，而后者有性能优势，让“语言”来执行调度，自己的事情自己做，只不过Loom似乎还打算支持yield点（Python中<code>generator</code>那样的东西，注意这个是无栈协程）。一切听起来都很美好，除了这个项目还未落地，在此之前，Kotlin可能是JVM平台异步编程的优选。</p>
<p>又或者，可以考虑阿里巴巴的Dragonwell？这个OpenJDK分支的Wisp2功能允许以一个JVM参数开启此功能，将几乎整个<code>Thread</code> API无缝转换成协程实现（Loom将会引入新的包与类，需要使用者显式地创建协程），在一个简单的实例中获得了数量级的性能提升。同时，绝大多数相关功能都被支持（包括整个JUC包），当然存在少数局限和注意事项。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说到这一步，我们会发现，如果不按具体层次讨论，标题中的三对概念就会变得格外混乱，根本无从议起。</p>
<p>难道JavaScript的异步编程只是个肤浅的称呼吗？它切实地解决了一些心智负担问题。在Node.js上也真的“异步”（运行在Node.js上的严格地讲是EMCAScript）。</p>
<p>难道并行流就不能在单核处理器的计算机上运行吗？当然可以。</p>
<p>程序员能确保并行代码一定在真正并行吗？这似乎主要是JVM，操作系统和硬件的事情，程序员仅仅提供了并行代码。</p>
<p>这些术语的使用有严格的界定吗？看看并行流和异步编程。</p>
<p>异步一定比同步好吗？非阻塞一定比阻塞好吗？并行一定比并发好吗？多线程一定比单线程好吗？这些问题只有一个确定而非常无聊的答案，根据实际情况而定。</p>
<p>没有什么魔法，不会因为几个概念的提出和辨明就能解决复杂的问题，问题永远会在那里，甚至不止一个。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/" class="post-title-link" itemprop="url">面向切面编程与come from</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-26 23:07:42" itemprop="dateCreated datePublished" datetime="2020-09-26T23:07:42+08:00">2020-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:18:28" itemprop="dateModified" datetime="2020-12-04T00:18:28+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>太阳底下没有新鲜事。</p>
<h2 id="goto与其批评"><a href="#goto与其批评" class="headerlink" title="goto与其批评"></a>goto与其批评</h2><p> goto在Java中是保留关键字而不可用（虽然在字节码里我们可以找到它），唯一接近的东西是带标签的<code>break</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) <span class="keyword">break</span> label;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这已经是它最常见的用法，跳出嵌套的控制语句，普通的<code>break</code>只能跳出当前循环。我相信多数人都对它很陌生，也许只有在极少的专注算法实现的代码里会用得上带标签的<code>break</code>语句。</p>
<p>许多编程语言都像java一样彻底不支持<code>goto</code>，或者十分有限地支持<code>goto</code>，当然也有不少语言（包括所谓新时代的语言）是完全支持的。<code>goto</code>被众多编程语言舍弃不是毫无理由的，数十年间，对<code>goto</code>的批评就没有停歇过，许多人认为，<code>goto</code>会造成混乱，它提供了一种强大的能力：让你随意跳转到当前作用域内任意处（这里说的是最原生态的那种<code>goto</code>）。确实容易想象这样的情景：你在查看既有代码，读到某一行时，忽然发现了<code>goto</code>，于是你跳转到它指向的位置，继续读下去却发现了另一个<code>goto</code>……最终，你得在脑海里梳理出一个便于理解的结构。</p>
<p>语法被滥用固然不全是语法本身的错，但像<code>goto</code>这样的语句格外容易被滥用，它太简单，效果却太强。<code>goto</code>代表的逻辑不是很符合人类的思维，“当怎样，就去哪里做什么云云”这样的思维活动大概只会在你看那些最不近人情的使用说明书时发生。</p>
<p>无论如何，这不会是一场有答案的争论，就像其他一切关于编程语言的哲学与风格的争论。</p>
<h2 id="comefrom，一个笑话"><a href="#comefrom，一个笑话" class="headerlink" title="comefrom，一个笑话"></a>comefrom，一个笑话</h2><p>如果你也认为<code>goto</code>确实比较糟糕，那你可能想不到它竟然能更糟，只需要把<code>goto</code>反转过来：运行到那处，跳转到此处。更糟的事情发生了，对于<code>goto</code>，你至少是明确地读到了它，清晰地意识到了这个跳转，但对于<code>comefrom</code>呢，你恐怕需要认真地看遍所有的代码，把它们都同时装在脑子里，才能进行结构梳理。</p>
<p>不用担心，<code>comefrom</code>从来都是一个笑话，没有任何高级编程语言严肃地考虑过实现它，曾经有人在愚人节发布了python的<code>goto</code>和<code>comefrom</code>实现，虽然确实可用，但它仍然不是认真的。</p>
<h2 id="AOP……？"><a href="#AOP……？" class="headerlink" title="AOP……？"></a>AOP……？</h2><p>现在从编程史话回到现实，重新考虑一下AOP，SpringAOP，每个Java程序员在最初接触到它时，都被灌输了一大堆概念：它是什么什么，它怎么怎么好，它不是OOP的代替而是补充……当尘埃落定，学会怎么用它之后，会发现也不过如此，我们用AOP做什么？日志记录，数据统计，统一异常处理，事务化。确实，如同最初得到的承诺，我们用AOP来做非核心业务的事情，并且效果斐然——毕竟把日志记录语句到处插入既杂乱又费事。</p>
<p>但是，这从来都不是AOP的全部。SpringAOP只用到了AspectJ的部分功能，SpringAOP仅仅允许用户切入方法（SpringAOP的within，this和target选择器功能并不完整），当用户试图使用AspectJ的其他切入点，程序会抛出<code>IllegalStateException</code>异常。而完整的AspectJ其实允许用户切入成员变量，构造器和控制流代码块。这部分是因为，SpringAOP的实现方式是动态代理（JDK原生和CGLib），而AspectJ的主要做法则是在编译时改造原有字节码（在这种实现里，相关行为被称为织入weave才更贴切，核心代码就像一件毛衣，而AspectJ把切面代码编织插入核心代码，就像在毛衣上点缀装饰），显然后者需要自己的编译器，实际上，AspectJ有着自己的语法和对应的一整套开发环境。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个Demo切入了Foo类的某个字段和所有构造器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">privileged</span> <span class="class"><span class="keyword">aspect</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt0</span>() : <span class="keyword">get</span>(* com.illuminatedworm.test.Foo.localDate);</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt1</span>() : <span class="keyword">initialization</span>(com.illuminatedworm.test.Foo.<span class="keyword">new</span>(..));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">before</span>() : pt0() || pt1() &#123;</span><br><span class="line">        System.out.println(<span class="string">"----Advice triggered----"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">thisJoinPoint</span>.toString());</span><br><span class="line">        System.out.println(<span class="string">"target: "</span> + <span class="keyword">thisJoinPoint</span>.getTarget());</span><br><span class="line">        System.out.println(<span class="string">"this: "</span> + <span class="keyword">thisJoinPoint</span>.getThis());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们当然可以只用AOP来方便日志记录业务，<strong><em>但AOP从来没有保证过自己只能做这样的事情</em></strong>，我们完全能修改方法的实参，甚至直接返回另一个不相干的结果。只是通常没人这么做罢了。</p>
<p>AOP难道不会令人想起<code>goto</code>和<code>comefrom</code>么？恕我大胆地说，AOP完全就是<code>comefrom</code>和<code>goto</code>的高级形式，而且更过分，切面与核心代码间的耦合度更低，像AspectJ这样的实现还帮你把相关上下文打包传递过来了（从这一点看，AOP是OOP的补充这种说法十分令人信服），只要愿意，程序员可以做许多事情。如果你认为这只是臆想，那么你真的该看看Aspectj的文档，编译时织入只是最简单的方式，只要用户愿意，编译后和加载时也可以进行织入，还有至今没有实现的运行时织入。</p>
<p>还记得我们假设的阅读带有<code>goto</code>和<code>comefrom</code>的代码是什么样的吗，阅读带有AOP的代码很难说会好到哪里去，把切面集中放到一个叫aspect的包里肯定很有帮助，但在庞大的工程里，模块和包数量众多。更荒唐的是，从察觉AOP的难易度来看，阅读被AspectJ编译器改造过的反编译代码远比阅读源代码容易察觉痕迹。</p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_2;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> ajc$preClinit() &#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory(<span class="string">"Foo.java"</span>, Foo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ajc$tjp_0 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">18</span>);</span><br><span class="line">        ajc$tjp_1 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">30</span>);</span><br><span class="line">        ajc$tjp_2 = factory.makeSJP(JoinPoint.INITIALIZATION, (Signature) factory.makeConstructorSig(World.xsetITD_VERSION_ORIGINAL, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>, <span class="string">"localDate"</span>, <span class="string">""</span>), <span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要因此认为AspectJ的实现方式比较糟糕，较真的话，这种实现方式性能更好，多创建几个对象和多运行几行代码的代价预期比SpringAOP的实现过程小。</p>
<h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>这里并没有贬低或者称赞任何东西。AOP，<code>goto</code>和<code>comeform</code>，它们如此地相似，“待遇”却截然不同，是AOP概念包装与实践门槛以及约定用法遏制了潜在的滥用吗？很难说得清，但我们可以发现，像是“只要怎样做就能如何好”这样的宣称几乎没有任何启示和指导作用，真正的价值仍然在于落到实处和如何落到实处。就像不要以AOP干预核心代码（事务化难道没有踩在这条红线上？我个人不是非常理解这怎么就不“核心”了），大家都明白，不过在其他时候，现成答案就不一定有了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">重新梳理泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 12:29:21" itemprop="dateCreated datePublished" datetime="2020-09-17T12:29:21+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:19:04" itemprop="dateModified" datetime="2020-12-04T00:19:04+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>主要参考：《Java核心技术 卷一》，《Effective Java》，Oracle官方文档。</p>
<p>本文中的“泛型”一词没有特别说明，皆指Java的泛型。</p>
<h2 id="0-对于应用程序员，究竟应该了解泛型到什么程度"><a href="#0-对于应用程序员，究竟应该了解泛型到什么程度" class="headerlink" title="0 对于应用程序员，究竟应该了解泛型到什么程度"></a>0 对于应用程序员，究竟应该了解泛型到什么程度</h2><p>《Java核心技术 卷一》提到了这个问题，作者把对泛型的了解分为三个档次。我基本同意这种看法，不过我在实践中感到这一套说法应该有所补充。原文大意：</p>
<blockquote>
<ul>
<li><p>第一个档次，对于大多数程序员，知道它存在并且能用上就行了，了解具体机制是不必要的。</p>
</li>
<li><p>第二个档次，了解泛型，当泛型的使用出现问题时，能够自己做到系统性的解决。</p>
</li>
<li><p>第三个档次，能自己编写参数化类型和泛型方法。</p>
</li>
</ul>
</blockquote>
<p>听起来很美好，好像可以为自己定下某个预期水平，根据所需降低学习成本。但至少对于我个人而言，事实并非如此。</p>
<p>第一个档次根本是个幻景，只知道在IDE的提示下往尖括号内填写东西，并对此有所经验，毫不夸张地说，就是对泛型一无所知。</p>
<p>第二个档次和第三个档次实际上是分不开的，了解泛型最好方法（我甚至相信是唯一可行的方法）就是自己编写参数化类型和泛型方法。起初，我抱着一种达到介于第一档次和第二档次之间的心态，但我很快发现了至少两点非常现实的问题：</p>
<ol>
<li>使用泛型时偶尔会出错，并且感到一头雾水。“为什么不能这么做”？</li>
<li>在学习<code>Stream</code>的用法时，看不懂<code>Comparator</code>等接口的API，其中有着像是<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>这样的方法，看起来有些惊人。</li>
</ol>
<p>第二点是更广泛实践的一部分，只要你对函数式编程，Lambda表达式，流有一丝兴趣，我相信你也遇到过类似的问题。</p>
<p>我为此仔细学习了泛型的通配符规则，在此期间产生了一篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>，那之后，我感觉我“比较彻底地解决问题了”，对泛型已经有了足够的了解。但是当我学习Sedgewick的《算法》，试着自己实现一些数据结构时，却感到涉及泛型时仍然“举步维艰”。</p>
<p>我最终意识到，我需要重新系统地梳理泛型。</p>
<p>其实这个话题可以推而广之，“对于应用程序员，究竟应该了解某某到什么程度”。有些东西的确是不需要深入的，例如类型推断，官方文档中用了一整章来讲Java的类型推断，当中大量地使用了数学语言，可以说很是晦涩难懂，但类型推断在几乎所有情况下都可以正常运作且效果符合直觉，网上可见的大多数所谓类型推断失败都源于错误使用，正当使用中要无意地使类型推断失效几乎不可能，并且从高抽象层面上理解它也非常便利，因此我认为大可接受类型推断的原理是黑箱。</p>
<h2 id="1-为什么要有泛型"><a href="#1-为什么要有泛型" class="headerlink" title="1 为什么要有泛型"></a>1 为什么要有泛型</h2><p>在Java中，强制类型转换是一件令人痛苦的事情，编译器站在严格的角度，不能确保任何强制类型转换是安全的，程序员得自己认真考虑所有可能情况。但强制类型转换又是必要的，最典型的是像<code>Collection</code>接口下众多的实现类，他们被用来存储其他对象，显然针对被存储对象的不同类型针对编写各种实现是不现实的，那么在以前采取的做法是，向上转型，转到Java的终极超类<code>Object</code>，用<code>Object</code>来囊括一切，如<code>ArrayList</code>就持有一个<code>Object[]</code>。</p>
<p>但这种做法导致了令人不快的现象，如：明明你往<code>Arraylist</code>中存入了<code>String</code>，从中取出时的却是<code>Object</code>，你不得不对返回值进行丑陋的强制类型转换，甚至因错误的转换出现<strong>运行时异常<code>ClassCastException</code></strong>。</p>
<p>以上种种烦恼在今天看来是不可思议的，甚至是荒唐的，这要归功于泛型。</p>
<h2 id="2-泛型是什么，有什么用"><a href="#2-泛型是什么，有什么用" class="headerlink" title="2 泛型是什么，有什么用"></a>2 泛型是什么，有什么用</h2><p>非常简单，泛型就是把对象类型当作参数一样可输入，介绍给编译器，让编译器去考虑它，将上述的问题从运行时“降低”到了编译时，任何程序员都知道，如果程序非要出错不可，编译时错误总好过运行时错误。在IDE的帮助下，甚至不需要等到真正编译的时候就能解决。</p>
<p>泛型的种种“复杂”都是为了确保这份美好愿景而衍生出的状况。</p>
<h2 id="3-泛型不是什么"><a href="#3-泛型不是什么" class="headerlink" title="3 泛型不是什么"></a>3 泛型不是什么</h2><p>谨记泛型只能保持到编译时（其实这个说法不够严谨，在运行时记录并利用泛型信息是可以做到的，Guava和一些序列化类库就这么做了。不过现在不关心反射那方面的事），为了保证它如你所愿的实现，编译器针对泛型做了名为“类型擦除”的一系列工作。</p>
<p>Java的泛型常常被拿来和C++的<code>Template</code>类或C#的泛型作比较，C++的<code>Template</code>类会真正的产生不同类型，而在Java中<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>严格地讲并不存在，这两个泛型类的表达依赖与原生的<code>ArrayList&lt;T&gt;</code>间的一种映射关系。</p>
<h2 id="4-类型擦除到底做了些什么"><a href="#4-类型擦除到底做了些什么" class="headerlink" title="4 类型擦除到底做了些什么"></a>4 类型擦除到底做了些什么</h2><p>为了将参数化类型映射到原本的类型，Java编译器进行了类型擦除。经常可以在网上看到像是“Java的泛型只是半吊子，它其实被类型擦除了”这样的说法，这样的说法在某种程度上是有道理的，参数化类型和原生类型的映射关系比起C++的模板类确实显得比较“脆弱”（参数化多态的问题水其实挺深的，对于Java只能期待Project Valhalla早日落成吧）。</p>
<p>类型擦除做了以下工作：</p>
<ol>
<li>将所有类型形参替换成指定的界限，如果没有指定界限则替换为<code>Object</code>。（所以没有像C++模板类实例化时那样真正的许多“参数化类型”存在）</li>
<li>在必要的地方插入强制类型转换，确保类型安全不被破坏。</li>
<li>生成桥接方法，确保多态不被破坏。</li>
</ol>
<p>现在借Oracle官方教程中故意错误使用的实例代码来理解这些工作（有所修改）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = mn;            <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);     </span><br><span class="line">Integer x = mn.data;</span><br></pre></td></tr></table></figure>
<p>使用代码被执行“类型擦除”后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = (MyNode)mn;         <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);</span><br><span class="line">Integer x = (String)mn.data;</span><br></pre></td></tr></table></figure>
<p>这样的使用毫无疑问是错误的，即使“参数化类型”并不存在，也不应该把<code>MyNode</code>实例声明为原生的<code>Node</code>类型，只是在继承时声明<code>Node&lt;Integer&gt;</code>是不行的。</p>
<p>异常<code>ClassCastException</code>于<code>n.setData(&quot;Hello&quot;)</code>这一行被抛出，而不是<code>Integer x = (String)mn.data</code>，这好像有点奇怪，<code>MyNode</code>中只有<code>setData(Integer)</code>，可代码确实通过编译并且被运行了，甚至抛出了一个异常。</p>
<p>以下是类被执行类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有什么不对劲，看似<code>MyNode</code>通过扩展<code>Node&lt;Integer&gt;</code>重写了<code>setData()</code>方法，实际上在类型擦除后，<code>Node</code>和<code>MyNode</code>中却分别出现了两个方法签名并不相同的方法<code>setData(Object)</code>和<code>setData(Integer)</code>，这不是重写（Override）而是重载（Overload），多态似乎被破坏了。为了确保多态，编译器在<code>MyNode</code>中生成了桥接方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    setData((Integer) data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正完成重写的方法是这个桥接方法，它连接超类方法和“重写方法”以确保多态，现在我们完全清楚地知道了为什么<code>n.setData(&quot;Hello&quot;)</code>可以通过编译并运行，最终还导致了<code>ClassCastException</code>，因为<code>MyNode</code>中确实有相应的方法。</p>
<h2 id="5-泛型的局限"><a href="#5-泛型的局限" class="headerlink" title="5 泛型的局限"></a>5 泛型的局限</h2><p>Oracle的用例非常巧妙，它既可以警示不当用法，还能借此令用户理解泛型。使用参数化类型的原生类型容易导致错误，这种错误是很容易意识到的，但它还有另一些不那么直观的不当用法（再次提一下其他参数化多态，比如，以下这些限制在C#中都是不存在的，而Java的Project Valhalla正试图解决5.1中的问题）。</p>
<h3 id="5-1-基本类型不能作为类型参数"><a href="#5-1-基本类型不能作为类型参数" class="headerlink" title="5.1 基本类型不能作为类型参数"></a>5.1 基本类型不能作为类型参数</h3><p>显然，基本类型不能被赋予声明为<code>Object</code>的变量，注意“字面量类型”和“基本类型”是有区别的，<code>String</code>可以作为参数化类型。解决方法也很简单，使用基本类型对应的包装类：<code>Integer</code>，<code>Long</code>等。但是要谨记，在处理大量数据时自动装箱和拆箱会导致明显的性能问题，JDK中有许多出于此考虑而专门针对基本类型的实现类，而不是简单地仅提供一个泛型类。</p>
<h3 id="5-2-不能用new-T-来创建实例"><a href="#5-2-不能用new-T-来创建实例" class="headerlink" title="5.2 不能用new T()来创建实例"></a>5.2 不能用new T()来创建实例</h3><p><code>Integer integer = new T()</code>在被执行类型擦除后会是<code>Integer integer = new Object()</code>，这肯定行不通。只能对传入的对象使用反射寻找构造器来创建。很不幸，泛型不能帮你省去编写反射代码的痛苦。</p>
<h3 id="5-3-不能用new-T-来创建数组"><a href="#5-3-不能用new-T-来创建数组" class="headerlink" title="5.3 不能用new T[]来创建数组"></a>5.3 不能用new T[]来创建数组</h3><p><code>T[] array = new T[1]</code>实际上是<code>Object[] array = new Object[0]</code>，这样就能放入任何对象，这明显有问题，最终Java决定完全拒绝这么做，用泛型创建数组会抛出编译错误。仍然需要对传入的对象使用反射，具体方法是<code>java.lang.reflect.Array.newInstance()</code>。</p>
<h3 id="5-4-不能创建参数化类型的数组"><a href="#5-4-不能创建参数化类型的数组" class="headerlink" title="5.4 不能创建参数化类型的数组"></a>5.4 不能创建参数化类型的数组</h3><p>类似上一点，这也是彻底不被允许的，<code>new Node&lt;Integer&gt;[1]</code>将不能通过编译。只能使用<code>Collection</code>来存储参数化类型，如<code>ArrayList&lt;Node&lt;Integer&gt;&gt;</code>。</p>
<h3 id="5-5-Varargs警告"><a href="#5-5-Varargs警告" class="headerlink" title="5.5 Varargs警告"></a>5.5 Varargs警告</h3><p>可变参数其实是以数组形式传入的，如果可变参数带有类型参数，就需要创建参数化类型的数组，不同于上一点，Java决定允许这么做，因为最常见的情况是只会从中读取元素，这么做不会有问题，可以放心地打上@SafeVarargs压制警告。但试图往当中添加或修改元素仍然是错误的。</p>
<h3 id="5-6-不能用类型形参进行类型检测和转换"><a href="#5-6-不能用类型形参进行类型检测和转换" class="headerlink" title="5.6 不能用类型形参进行类型检测和转换"></a>5.6 不能用类型形参进行类型检测和转换</h3><p>类似的考虑，Java完全拒绝这种意味不明的做法，<code>obj instanceof Node&lt;Integer&gt;</code>和<code>Node&lt;Integer&gt;obj</code>这样的语句都会抛出编译错误。</p>
<h3 id="5-6-静态字段和方法中不能引用类型变量"><a href="#5-6-静态字段和方法中不能引用类型变量" class="headerlink" title="5.6 静态字段和方法中不能引用类型变量"></a>5.6 静态字段和方法中不能引用类型变量</h3><p><code>static</code>代表着，这是属于类级别的成员，静态字段和静态方法将在所有实例之间共享，不同参数化类型的实例明显不能共享同一份静态成员，因此Java不允许这么做。</p>
<h3 id="5-7-不能捕获和抛出参数化类型的实例"><a href="#5-7-不能捕获和抛出参数化类型的实例" class="headerlink" title="5.7 不能捕获和抛出参数化类型的实例"></a>5.7 不能捕获和抛出参数化类型的实例</h3><p><code>catch (T e)</code>无论如何都是不行的，即使类型参数被声明为<code>T extends Throwable</code>也一样。为什么这样设计似乎有点似是而非，并且据我所知，Oracle官方并没有对此给出过解答，同时似乎也没有什么权威书籍做过什么论断。<strong>因此以下是未经任何认证的个人猜测，至少存在这种情况，如果允许捕获参数化类型的实例，代码会在编译后产生错误顺序的<code>catch</code>子句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;<span class="comment">// 如果允许这么做，那么没理由拒绝编译这样的代码</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型擦除后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">// 错误，IOExcpetion已被捕获</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数化类型也不能实现<code>Throwable</code>，因为异常可以持有引发自身的另一个异常，允许参数化类型实现<code>Throwable</code>可能导致类似的错误。</p>
<p><strong>请注意</strong>，所谓的抛出是指<code>throw</code>而不是<code>throws</code>，在中文语境中非常容易忽略这一点！后者可以声明适当的类型参数。</p>
<p>用泛型能对异常处理做出一些意想不到的操作，《Java核心技术 卷一》就提到过一种欺骗编译器某个检查型异常是运行时异常的操作，借以突破<code>Runnable</code>接口中的<code>run()</code>方法不允许抛出检查型异常的限制（显然，各种函数式接口也可以被这么做，或者，直接使用Apache Common中的可失败的函数式接口）。</p>
<p>在异常处理中使用泛型很难说有什么优势，却显然会导致混乱，这种做法或许应该彻底避免。</p>
<h3 id="5-8-小心潜在的方法签名冲突"><a href="#5-8-小心潜在的方法签名冲突" class="headerlink" title="5.8 小心潜在的方法签名冲突"></a>5.8 小心潜在的方法签名冲突</h3><p>由于类型擦除会改变方法签名，桥接方法会增加新方法，因此不能编写与之冲突的方法，有时潜在冲突不太明显，比如重写<code>Object</code>中的方法（其中的方法形参很多都是<code>Object</code>类）或复杂的继承情况。</p>
<h2 id="6-通配符，限定，PECS"><a href="#6-通配符，限定，PECS" class="headerlink" title="6 通配符，限定，PECS"></a>6 通配符，限定，PECS</h2><p>这里不会解释什么是不变性，协变性和逆变性，不过仍然需要了解这样的一个事实：</p>
<p><strong><code>List&lt;Integer&gt;</code>不是<code>List&lt;Number&gt;</code>的子类，类似情况皆是如此。</strong></p>
<p>这好像有一点不符合直觉，但其实很有道理。<br>子类继承了超类的所有成员并且能够新增自己的成员，子类的信息量必然大于或等于超类（这个认识也是之前那篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>的关键）。可以向<code>List&lt;Number&gt;</code>中放入<code>Long</code>对象，而不能对<code>List&lt;Integer&gt;</code>做这样的事，<code>List&lt;Number&gt;</code>能做的比<code>List&lt;Integer&gt;</code>多，但<strong><code>List&lt;Integer&gt;</code>也不是<code>List&lt;Number&gt;</code>的超类</strong>，这时不能只想着信息量，这里面首先就没有继承关系。</p>
<h3 id="6-1-extends限定"><a href="#6-1-extends限定" class="headerlink" title="6.1 extends限定"></a>6.1 extends限定</h3><p>道理是有了，事却坏了。<code>List&lt;E&gt;</code>有方法<code>addAll(Collection&lt;T&gt;)</code>，但不能向<code>List&lt;Number&gt;</code>中的<code>addAll()</code>方法中传入<code>Collection&lt;Integer&gt;</code>，因为它接受的参数类型现在是<code>Collection&lt;Number&gt;</code>。这显然不对劲。</p>
<p>我们需要<code>addAll()</code>方法的形参类型是“E的<strong><em>所有</em></strong>子类的<code>Collection</code>”，答案就是<code>Collection&lt;? extends T&gt;</code>，现在可以将<code>List&lt;Integer&gt;</code>传入<code>List&lt;Number&gt;</code>的<code>addAll()</code>方法了。</p>
<h3 id="6-2-super限定"><a href="#6-2-super限定" class="headerlink" title="6.2 super限定"></a>6.2 super限定</h3><p>那什么时候又（必须）用得着<code>&lt;? super T&gt;</code>呢，基本上是用在复杂继承时，考虑一个参数，它的抽象概念是“<strong><em>某个</em></strong>实现了针对自身的<code>Comparable</code>接口的类型”，考虑可能它的实参是<code>LocalDate</code>，这个类实现了<code>ChronoLocalDate</code>，而<code>ChronoLocalDate</code>又实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>LocalDate</code>其实实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>T extends Comparable&lt;T&gt;</code>是不行的，答案是<code>T extends Comparable&lt;? super T&gt;</code>，它的抽象概念是”<strong><em>某个</em></strong>实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口的类型“。</p>
<h3 id="6-3-PECS"><a href="#6-3-PECS" class="headerlink" title="6.3 PECS"></a>6.3 PECS</h3><p>太多的概念，太多复杂的表达，一点也不好运用和记忆。PECS就是为了助记而产生的——记住用处（在理解后）。</p>
<blockquote>
<ul>
<li>T只是产出者（只从中拿出）时，用&lt;? extends T&gt;代替T</li>
<li>T只是消费者（只往里填入）时，用&lt;? super T&gt;代替T</li>
<li>T既是消费者又是产出者，就用T</li>
</ul>
</blockquote>
<p>其实，PECS称得上是原则，几乎总是应该执行这三条规则。</p>
<h3 id="6-1-T，U，R，E，N，K，V和"><a href="#6-1-T，U，R，E，N，K，V和" class="headerlink" title="6.1 T，U，R，E，N，K，V和?"></a>6.1 T，U，R，E，N，K，V和?</h3><p>首先明确，只要是字母，就没有本质区别，不同的字母只是命名约定，出于解释和区分的考虑。可以在同一个作用域中声明多个类型参数，而<code>T</code>，<code>U</code>代表的意思是第一个类型参数和第二个类型参数，<code>T</code>来自Type，而<code>U</code>大概是因为在键盘上离T键近。<code>R</code>通常代表返回值。<code>E</code>代表Element，常见于<code>Collection</code>。<code>N</code>代表数字。<code>K</code>和<code>V</code>代表Key和Value，常见于<code>Map</code>。</p>
<p><code>?</code>则和字母有着真正的区别，在上文中，我用斜体加粗黑字标明了一些形容词，<strong><em>某个</em></strong>和<strong><em>所有</em></strong>形容了它们之间的区别，<code>?</code>并不匹配特定的类型，之所以会用<code>T</code>，是因为会再次用到这个类型，而用<code>?</code>是因为想指代多个，可以说，这两者间其实没有联系……</p>
<p>现在回到开头提到的<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>，终于能看懂了，它的类型参数列表的抽象概念是，“声明了两个类型参数，一个无限定，一个限定是实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口”，而形参类型也符合PECS——<code>Function</code>函数式接口接受一个值（消费者），返回一个值（产出者）。</p>
<p>无限定的<code>?</code>在类型擦除时会彻底消失，连<code>Object</code>也不会留下，所以使用无限定的<code>?</code>会很奇怪，考虑<code>setFoo(?)</code>和<code>? getFoo()</code>，前者究竟可以传入什么呢？答案是除了<code>null</code>什么都不能传入。至于后者，针对一个毕竟可能真实存在的对象，Java不能粗暴地当返回值是<code>void</code>处理，也不能返回给你一个“什么都不是”的东西，所以只好返回作为终极超类的<code>Object</code>类型。</p>
<h2 id="7-部分术语中英文对照"><a href="#7-部分术语中英文对照" class="headerlink" title="7 部分术语中英文对照"></a>7 部分术语中英文对照</h2><p>特别标明一下以下几个术语，我发现不少地方错误地把泛型接口称为泛型类，把参数化类型与类型变量或类型参数（实参/形参）搞混。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">中文</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">泛型类</td>
<td style="text-align:center">Generic class</td>
<td style="text-align:center">声明了类型变量的类</td>
</tr>
<tr>
<td style="text-align:center">泛型接口</td>
<td style="text-align:center">Generic Interface</td>
<td style="text-align:center">声明了类型变量的接口</td>
</tr>
<tr>
<td style="text-align:center">参数化类型</td>
<td style="text-align:center">Parameterized type</td>
<td style="text-align:center">指代泛型类或有类型形参的泛型接口</td>
</tr>
<tr>
<td style="text-align:center">类型变量</td>
<td style="text-align:center">Type variable</td>
<td style="text-align:center">不那么严格的表达，来自类，接口，方法和构造器中的类型实参的声明</td>
</tr>
<tr>
<td style="text-align:center">类型形参</td>
<td style="text-align:center">Type parameter</td>
<td style="text-align:center">类比于形参</td>
</tr>
<tr>
<td style="text-align:center">类型实参</td>
<td style="text-align:center">Type argument</td>
<td style="text-align:center">类比于实参</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">用JMH测试FastClass和反射的效率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:07:41" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:41+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:18:44" itemprop="dateModified" datetime="2020-12-04T00:18:44+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>现在来验证一下在Inflation优化下，Java反射和CGLib的<code>FastClass</code>哪个更高效。所用测试参数，JDK，JMH和JVM详情见输出结果。</p>
<h2 id="2-测试代码和输出结果"><a href="#2-测试代码和输出结果" class="headerlink" title="2 测试代码和输出结果"></a>2 测试代码和输出结果</h2><p>省略Bean类代码</p>
<p><code>FastClass</code>实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastClass;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastClass fastClass = FastClass.create(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastClassImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class[] noParam = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">        FastMethod getA = fastClass.getMethod(<span class="string">"getA"</span>, noParam);</span><br><span class="line">        FastMethod getB = fastClass.getMethod(<span class="string">"getB"</span>, noParam);</span><br><span class="line">        FastMethod getC = fastClass.getMethod(<span class="string">"getC"</span>, noParam);</span><br><span class="line">        FastMethod getD = fastClass.getMethod(<span class="string">"getD"</span>, noParam);</span><br><span class="line">        FastMethod setA = fastClass.getMethod(<span class="string">"setA"</span>, <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setB = fastClass.getMethod(<span class="string">"setB"</span>, <span class="keyword">new</span> Class[]&#123;Integer<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setC = fastClass.getMethod(<span class="string">"setC"</span>, <span class="keyword">new</span> Class[]&#123;Double<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setD = fastClass.getMethod(<span class="string">"setD"</span>, <span class="keyword">new</span> Class[]&#123;LocalDateTime<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj, noParam);</span><br><span class="line">        Object b = getB.invoke(originalObj, noParam);</span><br><span class="line">        Object c = getC.invoke(originalObj, noParam);</span><br><span class="line">        Object d = getD.invoke(originalObj, noParam);</span><br><span class="line"></span><br><span class="line">        Object clone = fastClass.newInstance();</span><br><span class="line">        setA.invoke(clone, <span class="keyword">new</span> Object[]&#123;a&#125;);</span><br><span class="line">        setB.invoke(clone, <span class="keyword">new</span> Object[]&#123;b&#125;);</span><br><span class="line">        setC.invoke(clone, <span class="keyword">new</span> Object[]&#123;c&#125;);</span><br><span class="line">        setD.invoke(clone, <span class="keyword">new</span> Object[]&#123;d&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>反射实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReflectionImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; oClass = originalObj.getClass();</span><br><span class="line"></span><br><span class="line">        Method getA = oClass.getMethod(<span class="string">"getA"</span>);</span><br><span class="line">        Method getB = oClass.getMethod(<span class="string">"getB"</span>);</span><br><span class="line">        Method getC = oClass.getMethod(<span class="string">"getC"</span>);</span><br><span class="line">        Method getD = oClass.getMethod(<span class="string">"getD"</span>);</span><br><span class="line">        Method setA = oClass.getMethod(<span class="string">"setA"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setB = oClass.getMethod(<span class="string">"setB"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setC = oClass.getMethod(<span class="string">"setC"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setD = oClass.getMethod(<span class="string">"setD"</span>, LocalDateTime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj);</span><br><span class="line">        Object b = getB.invoke(originalObj);</span><br><span class="line">        Object c = getC.invoke(originalObj);</span><br><span class="line">        Object d = getD.invoke(originalObj);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; constructor = oClass.getConstructor();</span><br><span class="line">        Object clone = constructor.newInstance();</span><br><span class="line">        setA.invoke(clone, a);</span><br><span class="line">        setB.invoke(clone, b);</span><br><span class="line">        setC.invoke(clone, c);</span><br><span class="line">        setD.invoke(clone, d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>基准性能测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">4</span>)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestBean TEST_BEAN = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cglib</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FastClassImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reflection</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果（部分）：</p>
<blockquote>
<p>JMH version: 1.25.2</p>
<p>VM version: JDK 1.8.0_251, Java HotSpot(TM) 64-Bit Server VM, 25.251-b08</p>
<p>Benchmark        Mode  Cnt     Score     Error  Units<br>Test.cglib       avgt    5  3614.397 ± 115.349  ns/op<br>Test.reflection  avgt    5  1502.978 ±  84.247  ns/op</p>
</blockquote>
<p>反射完胜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">CGLib之Enhancer小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:07:03" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:03+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:17:16" itemprop="dateModified" datetime="2020-12-04T00:17:16+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<p>参考资料：<a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">CGLib: The Missing Menual</a></p>
<h2 id="1-不要用非静态内部类创建Callback或者保存其为静态变量"><a href="#1-不要用非静态内部类创建Callback或者保存其为静态变量" class="headerlink" title="1 不要用非静态内部类创建Callback或者保存其为静态变量"></a>1 不要用非静态内部类创建Callback或者保存其为静态变量</h2><p>许多国内博客明显也参考了这份资料，然而他们都忽略了一个资料作者提及的重要事项：出于CGLib的实现原理，在创建<code>Enhancer</code>的类中使用匿名内部类创建<code>Callback</code>是危险的。资料作者使用匿名内部类只是为了简化演示代码。</p>
<p><strong>静态字段可以成为所谓的GC Root</strong>。</p>
<p><code>Enhancer</code>对象会为它的每个<code>Callback</code>创建一个私有的，静态的字段，而<code>Callback</code>本身在工作时，也会根据情况在<code>Enhancer</code>对象中加入静态字段。如果以匿名内部类创建<code>Callback</code>实例，由于非静态匿名内部类隐式地包含对外部类实例的引用，这会造成外部类实例，<code>Enhancer</code>对象和<code>Callback</code>对象之间交错的相互引用，静态字段加上循环引用非常容易妨碍到GC回收，这种情况下<code>Callback</code>对象<strong>永远</strong>不会被回收，这对于内存管理来说非常危险。</p>
<p>在CGLib的使用中用匿名内部类实现<code>Callback</code>的诱惑，相比在JDK动态中使用匿名内部类实现<code>InvocationHandler</code>更大，<code>InvocationHandler</code>通常需要包装被代理实例作为字段，在匿名内部类里做这一点显得非常冗长，而CGLib的代理对象是被代理对象的子类，能通过在<code>create()</code>方法中传入构造器形参类型和实参构造出完全代理被代理对象的实例。</p>
<p>普通的成员内部类也隐式地包含对外部类实例的引用，因此和非静态匿名内部类有同样的危险，但成员内部类的引用容易获得，至少能够管理（虽然这么做会非常麻烦且毫无道理），而匿名内部类则不能。</p>
<p>如果要用匿名内部类实现<code>Callback</code>，需要小心分辨。</p>
<h2 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2 测试代码"></a>2 测试代码</h2><p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal0</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal0 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal1 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divided</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallBack</code>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackDemo</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            objects[i] = (Integer) objects[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.Calculator;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.CallBackDemo;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackHelper;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer b = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator(<span class="string">"raw"</span>);</span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unit0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Calculator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        CallbackHelper callbackHelper = new CallbackHelper(Calculator.class, new Class[0]) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"cal1"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CallBackDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">        enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line"></span><br><span class="line">        Class[] argsType = &#123;String<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">        String[] arguments = &#123;<span class="string">"Proxy"</span>&#125;;</span><br><span class="line">        Calculator calculator = (Calculator) enhancer.create(argsType, arguments);</span><br><span class="line"></span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Calculator cal0 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0<br>Calculator cal1 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
<p>Calculator cal0 Proxy<br>plus: 12<br>minus: -4<br>times: 32<br>divided: 0<br>Calculator cal1 Proxy<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
</blockquote>
<h2 id="3-流程小结，Callback类鉴别"><a href="#3-流程小结，Callback类鉴别" class="headerlink" title="3 流程小结，Callback类鉴别"></a>3 流程小结，Callback类鉴别</h2><p>现在根据使用流程逐个总结使用细节。</p>
<p>在创建<code>Enhancer</code>对象后一定要使用<code>setSuperClass()</code>方法传入被代理类的类对象，即使<code>CallbackHelper</code>看起来也传入了被代理类的类对象，它不会为你完成这一步。</p>
<p><code>CallbackHelper</code>是<code>CallbackFilter</code>的默认实现类，设置过滤器的主要目的是将方法调用分发和具体的方法实现解耦，在这里做的工作基本就是根据方法名称调用不同的<code>Callback</code>。</p>
<p>使用<code>CallbackHelper</code>的情况下可以更简洁地为<code>Enhancer</code>设置<code>Callback</code>。如果不打算解耦分发逻辑和方法实现的话，或者分发逻辑较简单可以并入<code>Callback</code>，那么<code>CallbackHelper</code>并非必须的。</p>
<p><code>Callback</code>有如下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FixedValue</td>
<td style="text-align:center">简单地用另一个对象（通常是固定的）代替原本的返回值</td>
</tr>
<tr>
<td style="text-align:center">InvocationHandler</td>
<td style="text-align:center">大致与JDK动态代理用的InvocationHandler一样</td>
</tr>
<tr>
<td style="text-align:center">MethodInterceptor</td>
<td style="text-align:center">最全面，相比InvocationHandler多了一个MethodProxy类型的参数</td>
</tr>
<tr>
<td style="text-align:center">LazyLoader</td>
<td style="text-align:center">FixedValue的懒加载版，用于返回昂贵的对象</td>
</tr>
<tr>
<td style="text-align:center">Dispatcher</td>
<td style="text-align:center">每次方法调用都会重新生成返回对象，用于不改变对类的引用而改变其实现时</td>
</tr>
<tr>
<td style="text-align:center">ProxyRefDispatcher</td>
<td style="text-align:center">用于调用类的另一个方法</td>
</tr>
<tr>
<td style="text-align:center">NoOp</td>
<td style="text-align:center">使用被代理类原本的方法</td>
</tr>
</tbody>
</table>
</div>
<p><code>ProxyRefDispatcher</code>和<code>NoOp</code>基本上是用在解耦后的分发逻辑里的。<code>MethodInterceptor</code>虽然全面，但其他<code>Callback</code>更高效。</p>
<p><code>MethodInterceptor</code>提供的<code>MehtodProxy</code>对象有<code>invoke()</code>和<code>invokeSuper()</code>两个方法，前者用于对<strong>别的对象</strong>调用方法，后者才是对当前对象调用父类（被代理类）的方法。如果对当前对象使用<code>invoke()</code>将会导致死循环！</p>
<p>上文也提到过，CGLib的代理类是被代理类的子类，能轻易地完全摆脱被代理类实例，这可以在调用<code>create()</code>方法时完成。JDK动态代理不便于也不适宜完全取代被代理类实例。</p>
<p><code>Enhancer</code>作为CGLib中的重要使用对象，其API还是比较清晰明白的。CGLib适合于对未实现接口的类进行动态代理，但它创建新类的速度并没有JDK动态代理快，因此在Spring这种有数量不多的单例对象的情景里，只要目标实现了接口，Spring就选择Java原生代理。并且CGLib的动态代理的功能并非完全覆盖JDK动态代理——出于继承机制的限制，CGLib动态代理不能作用于<code>final</code>方法。</p>
<p>CGLib的<code>FastClass</code>通过直接对生成字节码来做到比反射更快。反射的底层是基于C语言的原生方法，其效率固然不那么快，然而HotSpot这样的现代JVM中有着inflation优化机制：反射JNI调用超过一定次数（默认为15）后，便会生成本地的字节码。在这种情况下，反射的效率劣势得到了一定程度的弥补，所以CGLib的<code>FastClass</code>也不是那么推荐了。悲伤的故事^ ^。</p>
<p>CGLib的主要问题在于，它会生成许多新类，消耗堆空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">SpringAOP小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:06:30" itemprop="dateCreated datePublished" datetime="2020-09-13T16:06:30+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-04 00:17:56" itemprop="dateModified" datetime="2020-12-04T00:17:56+08:00">2020-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <a id="more"></a>
<h2 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1 测试代码"></a>1 测试代码</h2><p>导入jar包省略。</p>
<p>Spring已配置包扫描，加入aspectj支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>“DAO”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Your input: "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“Service”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.annotation.WormCut;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDao;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDao</span><span class="params">(TestDaoImpl testDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDao = testDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m0 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@WormCut</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m1 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WormCut &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Aspect：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javasm.service.TestServiceImpl.m0(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.javasm.annotation.WormCut)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Execution of method "</span> + pjp.getSignature().getName() + <span class="string">" took "</span> + (end - start) + <span class="string">"ms."</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Before advice triggered."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"JoinPoint kind: "</span> + jp.getKind());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Method signature: "</span> + jp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"Args: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object arg : jp.getArgs()) &#123;</span><br><span class="line">            System.out.print(arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Target object hashcode: "</span> + jp.getTarget().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Proxy object hashcode: "</span> + jp.getThis().hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(jp.getStaticPart().toLongString());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"cut0()"</span>, returning = <span class="string">"obj"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(JoinPoint jp, Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterReturning advice triggered."</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"There is no returning Obj."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"cut0()"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwAdvice</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterThrowing advice triggered."</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"After advice triggered."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationBeforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Annotation pointcut success."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.service.TestService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">init</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        TestService testService = applicationContext.getBean(TestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        testService.m0(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">        testService.m1(<span class="string">"Hello Annotation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Before advice triggered.<br>JoinPoint kind: method-execution<br>Method signature: m0<br>Args: Hello Spring!<br>Target object hashcode: 790094605<br>Proxy object hashcode: -1294849058<br>execution(public abstract void com.javasm.service.TestService.m0(java.lang.String))</p>
<p>method m0 triggered.<br>Your input: Hello Spring!</p>
<p>AfterReturning advice triggered.<br>There is no returning Obj.</p>
<p>After advice triggered.</p>
<p>Execution of method m0 took 1007ms.</p>
<p>Annotation pointcut success.</p>
<p>method m1 triggered.<br>Your input: Hello Annotation!</p>
</blockquote>
<h2 id="2-流程小结，通知注释鉴别"><a href="#2-流程小结，通知注释鉴别" class="headerlink" title="2 流程小结，通知注释鉴别"></a>2 流程小结，通知注释鉴别</h2><p>将Contoller，Service和DAO等关键对象交给Spring管理，对于使用者来说，从亲手实现代理和在各处用代理对象替换被代理对象中解放出来，控制反转让施行真正的面向切面编程成为现实。（要注意的是SpringAOP采用的这种实现方式并不是唯一的，如AspectJ本身是在编译时通过专用编译器生成字节码来实现的）</p>
<p>需要声明切面，创建一个类，注释以<code>Aspect</code>并将其注入Spring。</p>
<p>然后建立空方法，以<code>@Pointcut</code>注释来声明需要切入处，主要方式有：</p>
<ol>
<li><p>execution方式，大致格式为“[返回值类型]空格[包|类|方法的全限定名]（形参类型）”。其中返回值和全限定名都可以以*作为通配符，形参类型可以写作“..”以省略。</p>
</li>
<li><p>@annotation方式，将定位反转，通过切入处的指定注释来找到切入处，注释必须用全限定名。</p>
</li>
</ol>
<p>最后建立方法，声明通知时机，通知时机的选择可见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">注释</th>
<th style="text-align:center">调用时机</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@Before</td>
<td style="text-align:center">切入方法调用前</td>
<td style="text-align:center">可以从JoinPoint中获得除了切入方法返回值外的多数信息</td>
</tr>
<tr>
<td style="text-align:center">@AfterReturning</td>
<td style="text-align:center">切入方法返回后</td>
<td style="text-align:center">在注释中赋值returning，可以获得切入方法返回值</td>
</tr>
<tr>
<td style="text-align:center">@AfterThrowing</td>
<td style="text-align:center">切入方法抛出异常后</td>
<td style="text-align:center">在注释中赋值throwing，可以获得切入方法抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">@After</td>
<td style="text-align:center">切入方法完成后</td>
<td style="text-align:center">不能获得什么信息</td>
</tr>
<tr>
<td style="text-align:center">@Around</td>
<td style="text-align:center">囊括以上</td>
<td style="text-align:center">最强大的通知，可以以ProceedingJoinPoint的proceed()方法划分切入方法执行前后。</td>
</tr>
</tbody>
</table>
</div>
<p>通过给@Around注释的方法中的<code>proceedingJoinPoint.proceed()</code>语句围绕try-catch-finally代码块，@Aroud注释的方法就能囊括所有其他调用时机。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IlluminatedWorm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  















  

  

  

</body>
</html>
