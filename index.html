<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="IlluminatedWorm&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IlluminatedWorm&#39;s Blog">
<meta property="article:author" content="IlluminatedWorm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>IlluminatedWorm's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">IlluminatedWorm's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IlluminatedWorm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/illuminatedworm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;illuminatedworm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:609210163@qq.com" title="E-Mail → mailto:609210163@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">异步与同步，阻塞与非阻塞，并发与并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-01 22:04:05" itemprop="dateCreated datePublished" datetime="2020-10-01T22:04:05+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-02 19:11:03" itemprop="dateModified" datetime="2020-10-02T19:11:03+08:00">2020-10-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Java并发编程实战》，稍微整理一下基础知识。<br>这些术语是上下文相关的，也就是说具体取决于讨论范围和语境。这里只从Java并发编程的角度展开。</p>
<p>在Java中，线程生命周期如下：</p>
<p><img src="异步与同步，阻塞与非阻塞，并发与并行/Thread.png" style="zoom:75%;" /></p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>相比标题里的前两者，并发和并行的区别更明显也更简单，所以第一个说。</p>
<p>借用名著《并发的艺术》的说法：</p>
<blockquote>
<p><em>A system is said to be</em> <em>concurrent</em> <em>if it can support two or more actions</em> <em>in progress</em> <em>at the same time. A system is said to be</em> <em>parallel</em> if it can support two or more actions executing simultaneously.</p>
<p>（如果某个系统支持两个或者多个动作同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。）</p>
</blockquote>
<p>区别在于“存在”和“执行”。</p>
<p>并发是指有多个线程都已经调用了<code>start()</code>，无论是在Java还是在其他领域，并发总是自然地被确保的，即使是在单核处理器的计算机上运行，多个线程也会交替地出入内存，也就是说，重点在于这些线程是同时存在的，仅此而已。</p>
<p>并行一定是指运行在多核处理器的计算机上的情况，多个线程被分配到不同的处理器内核上，真正的同时运行。</p>
<p>可以得出一些强化认识的推论：</p>
<ul>
<li>并行是并发的真子集。</li>
<li>对于单线程，这两个概念没有意义（Java程序肯定是多线程的——至少包括一个主线程和一个GC线程）。</li>
<li>在单核处理器的计算机上运行多线程程序一定是并发的。</li>
</ul>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>简单地说，阻塞与非阻塞就是关注线程是否会因某次操作而被挂起（等待，睡眠），而因为这几乎总是关乎系统调用，所以这对概念几乎总是与I/O一起被提及。之前已经说了本文只关注Java并发编程，不会讨论内核和底层的相关概念。</p>
<p>在<code>InputStream.read()</code>方法的文档中有这样的描述：</p>
<blockquote>
<p>Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.<br>If the length of b is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value -1 is returned; otherwise, at least one byte is read and stored into b. </p>
<p>从输入流中读入一些字节并将其存入缓冲数组b，实际读取的字节数将以整数形式返回。此方法将阻塞，直到输入数据可用，检测到文件末尾或某个异常被抛出。</p>
<p>如果b的长度为零，则没有字节（会）被读取，返回0；否则，试图读取至少一个字节。如果因流达到文件末尾导致无字节可用，返回值-1；否则，至少有一字节被读取并存入b。</p>
</blockquote>
<p>虽然非常不像是人话，但这已经说尽了阻塞：当发起<code>read()</code>方法调用，直到达成某些条件前，将没有可用的结果，不管这些条件是预料的正常读取还是别的情况。既然没有可用的结果，那么当前线程运行下去将是意味不明的，将其挂起是完全理所当然的做法。</p>
<p>而非阻塞是指，调用不会使得线程挂起，在定义上就是这么简单。</p>
<h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><p>再次声明，本文不会像许多同类讨论一样大谈内核和底层。在本文的讨论范围中，同步和阻塞完全是一回事，异步和非阻塞也是一回事。</p>
<p>但这样也导致本小节不会有什么真正可供鉴别的主题——<strong><em>抛掉硬件底层和操作系统层面的事情，所谓的异步与同步的差异，只是类库与框架呈现给程序员的表象</em></strong>。</p>
<p>本小节<strong>将通过JavaScript看异步编程</strong>，在Web编程中，因为AJAX的流行，从JavaScript中接触异步编程十分普遍。而Java的异步编程更多地见于JavaFX，Swing和数据分析等地方，相对地不是那么常见和便于举例。</p>
<p>许多Java程序员轻视JavaScript，以至于对<code>promise</code>对象所知甚少，但人人都见过这种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(f)</span><br><span class="line">.then(f1)</span><br><span class="line">.catch(e1)</span><br><span class="line">.then(f2)</span><br><span class="line">.catch(e2)</span><br></pre></td></tr></table></figure>
<p>它的抽象概念是，调用某个函数，如果它有成功的结果，调用f1，否则是失败的结果，调用e1，f1和e1又可能有成功和失败的结果，类似地，根据情况分别再调用f2和e2。</p>
<p>这就是JavaScript的异步编程，可以时常看到前端程序员津津乐道它，与<code>async</code>和<code>awiat</code>关键词一并提及，声称这是异步编程的最佳解决方案（尽管这对关键词先出现在C#中）。</p>
<p>但运行在某个浏览器中的JavaScript的代码总是阻塞的，JavaScript中根本没有线程概念，但它实际就是单线程的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码永远依次输出1，2，3，4。“主线程”在输出3之后，才去执行了<code>setTimeout</code>函数（实际上，Java中的<code>Timer</code>类也是这样的，真正的多线程定时任务需要<code>ScheduledThreadPoolExecutor</code>，原生定时任务的实现别再用<code>Timer</code>了）。</p>
<p>所以声称那是异步编程并不严谨，阻塞和非阻塞这对概念尚且关注的是一个对象的状态，但异步和同步关注的一定是至少两个对象间的关系，故而准确地讲，这应该叫作<em>异步风格编程</em>。它要解决的是程序员心智层面的认知问题，而不是CPU或者操作系统的问题。</p>
<p>JavaScript的实践中，经常会出现这种情况：这个函数需要那个函数的回调，另一个函数又需要这个函数的回调，甚至那个函数又依赖第四个函数的回调……在<code>promise</code>成为JavaScript官方规范和出现在第三方类库中之前，名为回调地狱的现象困扰着前端程序员，以下是一个夸张而搞笑的示例：</p>
<p><img src="异步与同步，阻塞与非阻塞，并发与并行/callback hell.jpeg" style="zoom:75%;" /></p>
<p>这样的代码看起来令人眼疼头疼，难以维护。现在的JavaScript，可以把这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">nextStep</span> =&gt;</span> &#123;</span><br><span class="line">  getBeef(<span class="function"><span class="keyword">function</span> (<span class="params">beef</span>) </span>&#123;</span><br><span class="line">    cookBeef(beef, <span class="function"><span class="keyword">function</span> (<span class="params">cookedBeef</span>) </span>&#123;</span><br><span class="line">      getBuns(<span class="function"><span class="keyword">function</span> (<span class="params">buns</span>) </span>&#123;</span><br><span class="line">        putBeefBetweenBuns(buns, beef, <span class="function"><span class="keyword">function</span>(<span class="params">burger</span>) </span>&#123;</span><br><span class="line">          nextStep(burger)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeBurger(<span class="function"><span class="keyword">function</span> (<span class="params">burger</span>) =&gt; </span>&#123;</span><br><span class="line">  serve(burger)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>变成这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(<span class="function"><span class="params">beef</span> =&gt;</span> cookBeef(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">cookedBeef</span> =&gt;</span> getBuns(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">bunsAndBeef</span> =&gt;</span> putBeefBetweenBuns(bunsAndBeef));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(<span class="function"><span class="params">burger</span> =&gt;</span> serve(burger));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用单参数函数的优势省略箭头函数的形式:</span></span><br><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(cookBeef)</span><br><span class="line">    .then(getBuns)</span><br><span class="line">    .then(putBeefBetweenBuns);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>甚至是这样的（ES6的generator也可以做到，在此不举例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beef = <span class="keyword">await</span> getBeef();</span><br><span class="line">  <span class="keyword">const</span> cookedBeef = <span class="keyword">await</span> cookBeef(beef);</span><br><span class="line">  <span class="keyword">const</span> buns = <span class="keyword">await</span> getBuns();</span><br><span class="line">  <span class="keyword">const</span> burger = <span class="keyword">await</span> putBeefBetweenBuns(cookedBeef, buns);</span><br><span class="line">  <span class="keyword">return</span> burger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>虽然每一行代码对应的具体<code>promise</code>对象的实现还是要落到程序员自己头上（所以还是那句话，没有什么魔法），但最终呈现的效果确实更清晰易读了。异步编程就是这样，只是一种风格，把有问题的实现方式换了一种实现方式（麻烦程度究竟有没有降低很难说，前端程序员中也有其他声音）。</p>
<p>JDK中也有着<code>promise</code>的等价物，即<code>CompetableFuture&lt;T&gt;</code>类，最本质的不同还是在于多线程，此类下的某些方法允许程序员将任务丢给其他线程执行。另外，<code>Collection</code>接口和<code>BaseStream</code>接口中分别提供了<code>parallelStream()</code>和<code>parallel()</code>方法，可以很方便地把原本的数据源并行化（这个说法是由方法名而来的，其实参考第一小节的结论，说是并发化更严谨），最终效果类似<code>async</code>和<code>await</code>关键词：写的是同步代码，执行却不是。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说到这一步，我们会发现，如果不按具体层次讨论，标题中的三对概念就会变得格外混乱，根本无从议起。</p>
<p>难道JavaScript的异步编程只是个肤浅的称呼吗？它切实地解决了一些心智负担问题。</p>
<p>难道并行流就不能在单核处理器的计算机上运行吗？当然可以。</p>
<p>程序员能确保并行代码一定在真正并行吗？这似乎主要是JVM，操作系统和硬件的事情，程序员仅仅提供了并行代码。</p>
<p>这些术语的使用有严格的界定吗？看看并行流和异步编程。</p>
<p>异步一定比同步好吗？阻塞一定比非阻塞好吗？并发一定比并行好吗？多线程一定比单线程好吗？这些问题只有一个确定而非常无聊的答案，根据实际情况而定。</p>
<p>没有什么魔法，不会因为几个概念的提出和辨明就能解决复杂的问题，问题永远会在那里，甚至不止一个。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/" class="post-title-link" itemprop="url">面向切面编程与come from</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-26 23:07:42" itemprop="dateCreated datePublished" datetime="2020-09-26T23:07:42+08:00">2020-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-27 01:58:55" itemprop="dateModified" datetime="2020-09-27T01:58:55+08:00">2020-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>太阳底下没有新鲜事。</p>
<h2 id="goto与其批评"><a href="#goto与其批评" class="headerlink" title="goto与其批评"></a>goto与其批评</h2><p> goto在Java中是保留关键字而不可用（虽然在字节码里我们可以找到它），唯一接近的东西是带标签的<code>break</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) <span class="keyword">break</span> label;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这已经是它最常见的用法，跳出嵌套的控制语句，普通的<code>break</code>只能跳出当前循环。我相信多数人都对它很陌生，也许只有在极少的专注算法实现的代码里会用得上带标签的<code>break</code>语句。</p>
<p>许多编程语言都像java一样彻底不支持<code>goto</code>，或者十分有限地支持<code>goto</code>，当然也有不少语言（包括所谓新时代的语言）是完全支持的。<code>goto</code>被众多编程语言舍弃不是毫无理由的，数十年间，对<code>goto</code>的批评就没有停歇过，许多人认为，<code>goto</code>会造成混乱，它提供了一种强大的能力：让你随意跳转到代码的某一处（这里说的是最原生态的那种<code>goto</code>）。确实容易想象这样的情景：你在查看既有代码，读到某一行时，忽然发现了<code>goto</code>，于是你跳转到它指向的位置，继续读下去却发现了另一个<code>goto</code>……最终，你得在脑海里梳理出一个便于理解的结构。</p>
<p>语法被滥用固然不全是语法本身的错，但像<code>goto</code>这样的语句格外容易被滥用，它太简单，效果却太强。<code>goto</code>代表的逻辑不是很符合人类的思维，“当怎样，就去哪里做什么云云”这样的思维活动大概只会在你看那些最不近人情的使用说明书时发生。</p>
<p>无论如何，这不会是一场有答案的争论，就像其他一切关于编程语言的哲学与风格的争论。</p>
<h2 id="comefrom，一个笑话"><a href="#comefrom，一个笑话" class="headerlink" title="comefrom，一个笑话"></a>comefrom，一个笑话</h2><p>如果你也认为<code>goto</code>确实比较糟糕，那你可能想不到它竟然能更糟，只需要把<code>goto</code>反转过来：运行到那处，跳转到此处。更糟的事情发生了，对于<code>goto</code>，你至少是明确地读到了它，清晰地意识到了这个跳转，但对于<code>comefrom</code>呢，你恐怕需要认真地看遍所有的代码，把它们都同时装在脑子里，才能进行结构梳理。</p>
<p>不用担心，<code>comefrom</code>从来都是一个笑话，没有任何高级编程语言严肃地考虑过实现它，曾经有人在愚人节发布了python的<code>goto</code>和<code>comefrom</code>实现，虽然确实可用，但它仍然不是认真的。</p>
<h2 id="AOP……？"><a href="#AOP……？" class="headerlink" title="AOP……？"></a>AOP……？</h2><p>现在从编程史话回到现实，重新考虑一下AOP，SpringAOP，每个Java程序员在最初接触到它时，都被灌输了一大堆概念：它是什么什么，它怎么怎么好，它不是OOP的代替而是补充……当尘埃落定，学会怎么用它之后，会发现也不过如此，我们用AOP做什么？日志记录，数据统计，统一异常处理，事务化。确实，如同最初得到的承诺，我们用AOP来做非核心业务的事情，并且效果斐然——毕竟把日志记录语句到处插入既杂乱又费事。</p>
<p>但是，这从来都不是AOP的全部。SpringAOP只用到了AspectJ的部分功能，SpringAOP仅仅允许用户切入方法（SpringAOP的within，this和target选择器功能并不完整），当用户试图使用AspectJ的其他切入点，程序会抛出<code>IllegalStateException</code>异常。而完整的AspectJ其实允许用户切入成员变量，构造器和控制流代码块。这部分是因为，SpringAOP的实现方式是动态代理（JDK原生和CGLib），而AspectJ的主要做法则是在编译时改造原有字节码（在这种实现里，相关行为被称为织入weave才更贴切，核心代码就像一件毛衣，而AspectJ把切面代码编织插入核心代码，就像在毛衣上点缀装饰），显然后者需要自己的编译器，实际上，AspectJ有着自己的语法，和对应的一整套开发环境。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个Demo切入了Foo类的某个字段和所有构造器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">privileged</span> <span class="class"><span class="keyword">aspect</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt0</span>() : <span class="keyword">get</span>(* com.illuminatedworm.test.Foo.localDate);</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt1</span>() : <span class="keyword">initialization</span>(com.illuminatedworm.test.Foo.<span class="keyword">new</span>(..));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">before</span>() : pt0() || pt1() &#123;</span><br><span class="line">        System.out.println(<span class="string">"----Advice triggered----"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">thisJoinPoint</span>.toString());</span><br><span class="line">        System.out.println(<span class="string">"target: "</span> + <span class="keyword">thisJoinPoint</span>.getTarget());</span><br><span class="line">        System.out.println(<span class="string">"this: "</span> + <span class="keyword">thisJoinPoint</span>.getThis());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们当然可以只用AOP来方便日志记录业务，<strong><em>但AOP从来没有保证过自己只能做这样的事情</em></strong>，我们完全能修改方法的实参，甚至直接返回另一个不相干的结果。只是通常没人这么做罢了。</p>
<p>AOP难道不会令人想起<code>goto</code>和<code>comefrom</code>么？恕我大胆地说，AOP完全就是<code>comefrom</code>和<code>goto</code>的高级形式，而且更过分，切面与核心代码间的耦合度更低，像AspectJ这样的实现还帮你把相关上下文打包传递过来了（从这方面想，AOP是OOP的补充十分令人信服），只要愿意，程序员可以做许多事情。如果你认为这只是臆想，那么你真的该看看Aspectj的文档，编译时织入只是最简单的方式，只要用户愿意，编译后和加载时也可以进行织入，还有至今没有实现的运行时织入。</p>
<p>还记得我们假设的阅读带有<code>goto</code>和<code>comefrom</code>的代码是什么样的吗，阅读带有AOP的代码很难说会好到哪里去，把切面集中放到一个叫aspect的包里可能有帮助，但在庞大的工程里，模块和包数量众多。更荒唐的是，从察觉AOP的难易度来看，阅读被AspectJ编译器改造后的反编译代码远比阅读源代码容易察觉痕迹。</p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_2;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> ajc$preClinit() &#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory(<span class="string">"Foo.java"</span>, Foo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ajc$tjp_0 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">18</span>);</span><br><span class="line">        ajc$tjp_1 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">30</span>);</span><br><span class="line">        ajc$tjp_2 = factory.makeSJP(JoinPoint.INITIALIZATION, (Signature) factory.makeConstructorSig(World.xsetITD_VERSION_ORIGINAL, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>, <span class="string">"localDate"</span>, <span class="string">""</span>), <span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要因此认为AspectJ的实现方式比较糟糕，较真的话，这种实现方式性能更好，多创建几个对象和多运行几行代码的代价可比动态代理小多了。</p>
<h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>AOP是好的，<code>goto</code>并不是十恶不赦的，<code>comefrom</code>也许真有用武之地。它们如此地相似，风评却截然不同，是AOP概念包装与实践门槛以及约定用法限制了潜在的滥用吗？很难说得清，但得出这么一条结论是不难的：“只要怎样做，就能如何好”这样的说法实在欠奉，真正的价值关乎落到实处和如何落到实处。就像不要以AOP干预核心代码（事务化难道没有踩在这条红线上？），大家都明白，但在其他时候，现成的答案并不总有。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">重新梳理泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 12:29:21" itemprop="dateCreated datePublished" datetime="2020-09-17T12:29:21+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-25 21:39:20" itemprop="dateModified" datetime="2020-09-25T21:39:20+08:00">2020-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>主要参考：《Java核心技术 卷一》，《Effective Java》，Oracle官方文档。</p>
<h2 id="0-对于应用程序员，究竟应该了解泛型到什么程度"><a href="#0-对于应用程序员，究竟应该了解泛型到什么程度" class="headerlink" title="0 对于应用程序员，究竟应该了解泛型到什么程度"></a>0 对于应用程序员，究竟应该了解泛型到什么程度</h2><p>《Java核心技术 卷一》提到了这个问题，作者把对泛型的了解分为三个档次。我基本同意这种看法，不过我在实践中感到这一套说法应该有所补充。原文大意：</p>
<blockquote>
<ul>
<li><p>第一个档次，对于大多数程序员，知道它存在并且能用上就行了，了解具体机制是不必要的。</p>
</li>
<li><p>第二个档次，了解泛型，当泛型的使用出现问题时，能够自己做到系统性的解决。</p>
</li>
<li><p>第三个档次，能自己编写参数化类型和泛型方法。</p>
</li>
</ul>
</blockquote>
<p>听起来很美好，好像可以为自己定下某个预期水平，根据所需降低学习成本。但至少对于我个人而言，事实并非如此。</p>
<p>第一个档次根本是个幻景，只知道在IDE的提示下往尖括号内填写东西，并对此有所经验，毫不夸张地说，就是对泛型一无所知。</p>
<p>第二个档次和第三个档次实际上是分不开的，了解泛型最好方法（我甚至相信是唯一可行的方法）就是自己编写参数化类型和泛型方法。起初，我抱着一种达到介于第一档次和第二档次之间的心态，但我很快发现了至少两点非常现实的问题：</p>
<ol>
<li>使用泛型时偶尔会出错，并且感到一头雾水。“为什么不能这么做”？</li>
<li>在学习<code>Stream</code>的用法时，看不懂<code>Comparator</code>等接口的API，其中有着像是<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>这样的方法，看起来有些惊人。</li>
</ol>
<p>第二点是更广泛实践的一部分，只要你对函数式编程，Lambda表达式，流有一丝兴趣，我相信你也遇到过类似的问题。</p>
<p>我为此仔细学习了泛型的通配符规则，在此期间产生了一篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>，那之后，我感觉我“比较彻底地解决问题了”，对泛型已经有了足够的了解。但是当我学习Sedgewick的《算法》，试着自己实现一些数据结构时，却感到涉及泛型时仍然“举步维艰”。</p>
<p>我最终意识到，我需要重新系统地梳理泛型。</p>
<p>其实这个话题可以推而广之，“对于应用程序员，究竟应该了解某某到什么程度”。有些东西的确是不需要深入的，例如类型推断，官方文档中用了一整章来讲Java的类型推断，当中大量地使用了数学语言，可以说很是晦涩难懂，但类型推断在几乎所有情况下都可以正常运作且效果符合直觉，网上可见的大多数所谓类型推断失败都源于错误使用，正当使用中要无意地使类型推断失效几乎不可能，并且从高抽象层面上理解它也非常便利，因此我认为大可接受类型推断的原理是黑箱。</p>
<h2 id="1-为什么要有泛型"><a href="#1-为什么要有泛型" class="headerlink" title="1 为什么要有泛型"></a>1 为什么要有泛型</h2><p>在Java中，强制类型转换是一件令人痛苦的事情，编译器站在严格的角度，不能确保任何强制类型转换是安全的，程序员得自己认真考虑所有可能情况。但强制类型转换又是必要的，最典型的是像<code>Collection</code>接口下众多的实现类，他们被用来存储其他对象，显然针对被存储对象的不同类型针对编写各种实现是不现实的，那么在以前采取的做法是，向上转型，转到Java的终极超类<code>Object</code>，用<code>Object</code>来囊括一切，如<code>ArrayList</code>就持有一个<code>Object[]</code>。</p>
<p>但这种做法导致了令人不快的现象，如：明明你往<code>Arraylist</code>中存入了<code>String</code>，从中取出时的却是<code>Object</code>，你不得不对返回值进行丑陋的强制类型转换，甚至因错误的转换出现<strong>运行时异常<code>ClassCastException</code></strong>。</p>
<p>以上种种烦恼在今天看来是不可思议的，甚至是荒唐的，这要归功于泛型。</p>
<h2 id="2-泛型是什么，有什么用"><a href="#2-泛型是什么，有什么用" class="headerlink" title="2 泛型是什么，有什么用"></a>2 泛型是什么，有什么用</h2><p>非常简单，泛型就是把对象类型当作参数一样可输入，介绍给编译器，让编译器去考虑它，将上述的问题从运行时“降低”到了编译时，任何程序员都知道，如果程序非要出错不可，编译时错误总好过运行时错误。在IDE的帮助下，甚至不需要等到真正编译的时候就能解决。</p>
<p>泛型的种种“复杂”都是为了确保这份美好愿景而衍生出的状况。</p>
<h2 id="3-泛型不是什么"><a href="#3-泛型不是什么" class="headerlink" title="3 泛型不是什么"></a>3 泛型不是什么</h2><p>谨记泛型只能保持到编译时（其实这个说法不够严谨，不过现在不关心反射那方面的事），为了保证它如你所愿的实现，编译器针对泛型做了名为“类型擦除”的一系列工作。</p>
<p>Java的泛型常常被拿来和C++的<code>Template</code>类作比较，这种比较是有道理的，它们要实现的概念类似而实现的方式却不同，C++的<code>Template</code>类在实例化时会真正的产生不同类型，而在Java中<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>严格地讲并不存在，这两个泛型类的表达依赖与原生的<code>ArrayList&lt;T&gt;</code>间的一种映射关系。</p>
<h2 id="4-类型擦除到底做了些什么"><a href="#4-类型擦除到底做了些什么" class="headerlink" title="4 类型擦除到底做了些什么"></a>4 类型擦除到底做了些什么</h2><p>为了将参数化类型映射到原本的类型，Java编译器进行了类型擦除。经常可以在网上看到像是“Java的泛型只是半吊子，它其实被类型擦除了”这样的说法，这样的说法在某种程度上是有道理的，参数化类型和原生类型的映射关系比起C++的模板类确实显得比较“脆弱”，这是不同实现方式的优缺点不同。</p>
<p>类型擦除做了以下工作：</p>
<ol>
<li>将所有类型形参替换成指定的界限，如果没有指定界限则替换为<code>Object</code>。（所以没有像C++模板类实例化时那样真正的许多“参数化类型”存在）</li>
<li>在必要的地方插入强制类型转换，确保类型安全不被破坏。</li>
<li>生成桥接方法，确保多态不被破坏。</li>
</ol>
<p>现在借Oracle官方教程中故意错误使用的实例代码来理解这些工作（有所修改）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = mn;            <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);     </span><br><span class="line">Integer x = mn.data;</span><br></pre></td></tr></table></figure>
<p>使用代码被执行类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = (MyNode)mn;         <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);</span><br><span class="line">Integer x = (String)mn.data;</span><br></pre></td></tr></table></figure>
<p>这样的使用毫无疑问是错误的，即使“参数化类型”并不存在，也不应该把<code>MyNode</code>实例声明为原生的<code>Node</code>类型，只是在继承时声明<code>Node&lt;Integer&gt;</code>是不行的。</p>
<p>异常<code>ClassCastException</code>于<code>n.setData(&quot;Hello&quot;)</code>这一行被抛出，而不是<code>Integer x = (String)mn.data</code>，这好像有点奇怪，<code>MyNode</code>中只有<code>setData(Integer)</code>，可代码确实通过编译并且被运行了，甚至抛出了一个异常。</p>
<p>以下是类被执行类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有什么不对劲，看似<code>MyNode</code>通过扩展<code>Node&lt;Integer&gt;</code>重写了<code>setData()</code>方法，实际上在类型擦除后，<code>Node</code>和<code>MyNode</code>中却分别出现了两个方法签名并不相同的方法<code>setData(Object)</code>和<code>setData(Integer)</code>，这不是重写（Override）而是重载（Overload），多态似乎被破坏了。为了确保多态，编译器在<code>MyNode</code>中生成了桥接方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    setData((Integer) data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正完成重写的方法是这个桥接方法，它连接超类方法和“重写方法”以确保多态，现在我们完全清楚地知道了为什么<code>n.setData(&quot;Hello&quot;)</code>可以通过编译并运行，最终还导致了<code>ClassCastException</code>，因为<code>MyNode</code>中确实有相应的方法。</p>
<h2 id="5-泛型的局限"><a href="#5-泛型的局限" class="headerlink" title="5 泛型的局限"></a>5 泛型的局限</h2><p>Oracle的用例非常巧妙，它既可以警示不当用法，还能借此令用户理解泛型。使用参数化类型的原生类型容易导致错误，这种错误是很容易意识到的，但它还有另一些不那么直观的不当用法。</p>
<h3 id="5-1-基本类型不能作为类型参数"><a href="#5-1-基本类型不能作为类型参数" class="headerlink" title="5.1 基本类型不能作为类型参数"></a>5.1 基本类型不能作为类型参数</h3><p>显然，基本类型不能被赋予声明为<code>Object</code>的变量，注意“字面量类型”和“基本类型”是有区别的，<code>String</code>可以作为参数化类型。解决方法也很简单，使用基本类型对应的包装类：<code>Integer</code>，<code>Long</code>等。但是要谨记，在处理大量数据时自动装箱和拆箱会导致明显的性能问题，JDK中有许多出于此考虑而专门针对基本类型的实现类，而不是简单地仅提供一个泛型类。</p>
<h3 id="5-2-不能用new-T-来创建实例"><a href="#5-2-不能用new-T-来创建实例" class="headerlink" title="5.2 不能用new T()来创建实例"></a>5.2 不能用new T()来创建实例</h3><p><code>Integer integer = new T()</code>在被执行类型擦除后会是<code>Integer integer = new Object()</code>，这肯定行不通。只能对传入的对象使用反射寻找构造器来创建。很不幸，泛型不能帮你省去编写反射代码的痛苦。</p>
<h3 id="5-3-不能用new-T-来创建数组"><a href="#5-3-不能用new-T-来创建数组" class="headerlink" title="5.3 不能用new T[]来创建数组"></a>5.3 不能用new T[]来创建数组</h3><p><code>T[] array = new T[1]</code>实际上是<code>Object[] array = new Object[0]</code>，这样就能放入任意对象，这明显有问题，最终Java决定完全拒绝这么做，用泛型创建数组会抛出编译错误。仍然需要对传入的对象使用反射，具体方法是<code>java.lang.reflect.Array.newInstance()</code>。</p>
<h3 id="5-4-不能创建参数化类型的数组"><a href="#5-4-不能创建参数化类型的数组" class="headerlink" title="5.4 不能创建参数化类型的数组"></a>5.4 不能创建参数化类型的数组</h3><p>类似上一点，这也是彻底不被允许的，<code>new Node&lt;Integer&gt;[1]</code>将不能通过编译。只能使用<code>Collection</code>来存储参数化类型，如<code>ArrayList&lt;Node&lt;Integer&gt;&gt;</code>。</p>
<h3 id="5-5-Varargs警告"><a href="#5-5-Varargs警告" class="headerlink" title="5.5 Varargs警告"></a>5.5 Varargs警告</h3><p>可变参数其实是以数组形式传入的，如果可变参数带有类型参数，就需要创建参数化类型的数组，不同于上一点，Java决定允许这么做，因为最常见的情况是只会从中读取元素，这么做不会有问题，可以放心地打上@SafeVarargs压制警告。但试图往当中添加或修改元素仍然是错误的。</p>
<h3 id="5-6-不能用类型形参进行类型检测和转化"><a href="#5-6-不能用类型形参进行类型检测和转化" class="headerlink" title="5.6 不能用类型形参进行类型检测和转化"></a>5.6 不能用类型形参进行类型检测和转化</h3><p>类似的考虑，Java完全拒绝这种意味不明的做法，<code>obj instanceof Node&lt;Integer&gt;</code>和<code>Node&lt;Integer&gt;obj</code>这样的语句都会抛出编译错误。</p>
<h3 id="5-6-静态字段和方法中不能引用类型变量"><a href="#5-6-静态字段和方法中不能引用类型变量" class="headerlink" title="5.6 静态字段和方法中不能引用类型变量"></a>5.6 静态字段和方法中不能引用类型变量</h3><p><code>static</code>代表着，这是属于类级别的成员，静态字段和静态方法将在所有实例之间共享，不同参数化类型的实例明显不能共享同一份静态成员，因此Java不允许这么做。</p>
<h3 id="5-7-不能捕获和抛出参数化类型的实例"><a href="#5-7-不能捕获和抛出参数化类型的实例" class="headerlink" title="5.7 不能捕获和抛出参数化类型的实例"></a>5.7 不能捕获和抛出参数化类型的实例</h3><p><code>catch (T e)</code>无论如何都是不行的，即使类型参数被声明为<code>T extends Throwable</code>也一样。为什么这样设计似乎有点似是而非，并且据我所知，Oracle官方并没有对此给出过解答，同时似乎也没有什么权威书籍做过什么论断。<strong>因此以下是未经任何认证的个人猜测，至少存在这种情况，如果允许捕获参数化类型的实例，代码会在编译后产生错误顺序的<code>catch</code>子句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;<span class="comment">// 如果允许这么做，那么没理由拒绝编译这样的代码</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型擦除后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">// 错误，IOExcpetion已被捕获</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数化类型也不能实现<code>Throwable</code>，因为异常可以持有引发自身的另一个异常，允许参数化类型实现<code>Throwable</code>可能导致类似的错误。</p>
<p><strong>请注意</strong>，所谓的抛出是指<code>throw</code>而不是<code>throws</code>，在中文语境中非常容易忽略这一点！后者可以声明适当的类型参数。</p>
<p>用泛型能对异常处理做出一些意想不到的操作，《Java核心技术 卷一》就提到过一种欺骗编译器某个检查型异常是运行时异常的操作，借以突破<code>Runnable</code>接口中的<code>run()</code>方法不允许抛出检查型异常的限制（显然，各种函数式接口也可以被这么做）。</p>
<p>在异常处理中使用泛型很难说有什么优势，却显然会导致混乱，这种做法或许应该彻底避免。</p>
<h3 id="5-8-小心潜在的方法签名冲突"><a href="#5-8-小心潜在的方法签名冲突" class="headerlink" title="5.8 小心潜在的方法签名冲突"></a>5.8 小心潜在的方法签名冲突</h3><p>由于类型擦除会改变方法签名，桥接方法会增加新方法，因此不能编写与之冲突的方法，有时潜在冲突不太明显，比如重写<code>Object</code>中的方法（其中的方法形参很多都是<code>Object</code>类）或复杂的继承情况。</p>
<h2 id="6-通配符，限定，PECS"><a href="#6-通配符，限定，PECS" class="headerlink" title="6 通配符，限定，PECS"></a>6 通配符，限定，PECS</h2><p>这里不会解释什么是不变性，协变性和逆变性，不过仍然需要了解这样的一个事实：</p>
<p><strong><code>List&lt;Integer&gt;</code>不是<code>List&lt;Number&gt;</code>的子类，类似情况皆是如此。</strong></p>
<p>这好像有一点不符合直觉，但其实很有道理。<br>子类继承了超类的所有成员并且能够新增自己的成员，子类的信息量必然大于或等于超类（这个认识也是之前那篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>的关键）。可以向<code>List&lt;Number&gt;</code>中放入<code>Long</code>对象，而不能对<code>List&lt;Integer&gt;</code>做这样的事，<code>List&lt;Number&gt;</code>能做的比<code>List&lt;Integer&gt;</code>多，但<strong><code>List&lt;Integer&gt;</code>也不是<code>List&lt;Number&gt;</code>的超类</strong>，这时不能只想着信息量，这里面首先就没有继承关系。</p>
<h3 id="6-1-extends限定"><a href="#6-1-extends限定" class="headerlink" title="6.1 extends限定"></a>6.1 extends限定</h3><p>道理是有了，事却坏了。<code>List&lt;E&gt;</code>有方法<code>addAll(Collection&lt;T&gt;)</code>，但不能向<code>List&lt;Number&gt;</code>中的<code>addAll()</code>方法中传入<code>Collection&lt;Integer&gt;</code>，因为它接受的参数类型现在是<code>Collection&lt;Number&gt;</code>。这显然不对劲。</p>
<p>我们需要<code>addAll()</code>方法的形参类型是“E的<strong><em>所有</em></strong>子类的<code>Collection</code>”，答案就是<code>Collection&lt;? extends T&gt;</code>，现在可以将<code>List&lt;Integer&gt;</code>传入<code>List&lt;Number&gt;</code>的<code>addAll()</code>方法了。</p>
<h3 id="6-2-super限定"><a href="#6-2-super限定" class="headerlink" title="6.2 super限定"></a>6.2 super限定</h3><p>那什么时候又（必须）用得着<code>&lt;? super T&gt;</code>呢，基本上是用在复杂继承时，考虑一个参数，它的抽象概念是“<strong><em>某个</em></strong>实现了针对自身的<code>Comparable</code>接口的类型”，考虑可能它的实参是<code>LocalDate</code>，这个类实现了<code>ChronoLocalDate</code>，而<code>ChronoLocalDate</code>又实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>LocalDate</code>其实实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>T extends Comparable&lt;T&gt;</code>是不行的，答案是<code>T extends Comparable&lt;? super T&gt;</code>，它的抽象概念是”<strong><em>某个</em></strong>实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口的类型“。</p>
<h3 id="6-3-PECS"><a href="#6-3-PECS" class="headerlink" title="6.3 PECS"></a>6.3 PECS</h3><p>太多的概念，太多复杂的表达，一点也不好运用和记忆。PECS就是为了助记而产生的——记住用处（在理解后）。</p>
<blockquote>
<ul>
<li>T只是产出者（只从中拿出）时，用&lt;? extends T&gt;代替T</li>
<li>T只是消费者（只往里填入）时，用&lt;? super T&gt;代替T</li>
<li>T既是消费者又是产出者，就用T</li>
</ul>
</blockquote>
<p>其实，PECS称得上是原则，几乎总是应该服从这三条规则。</p>
<h3 id="6-1-T，U，R，E，N，K，V和"><a href="#6-1-T，U，R，E，N，K，V和" class="headerlink" title="6.1 T，U，R，E，N，K，V和?"></a>6.1 T，U，R，E，N，K，V和?</h3><p>首先明确，只要是字母，就没有本质区别，不同的字母只是命名约定，出于解释和区分的考虑。可以在同一个作用域中声明多个类型参数，而<code>T</code>，<code>U</code>代表的意思是第一个类型参数和第二个类型参数，<code>T</code>来自Type，而<code>U</code>大概是因为在键盘上离T键近。<code>R</code>通常代表返回值。<code>E</code>代表Element，常见于<code>Collection</code>。<code>N</code>代表数字。<code>K</code>和<code>V</code>代表Key和Value，常见于<code>Map</code>。</p>
<p><code>?</code>则和字母有着真正的区别，在上文中，我用斜体加粗黑字标明了一些形容词，<strong><em>某个</em></strong>和<strong><em>所有</em></strong>形容了它们之间的区别，<code>?</code>并不匹配特定的类型，之所以会用<code>T</code>，是因为会再次用到这个类型，而用<code>?</code>是因为想指代多个，可以说，这两者间其实没有联系……</p>
<p>现在回到开头提到的<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>，终于能看懂了，它的类型参数列表的抽象概念是，“声明了两个类型参数，一个无限定，一个限定是实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口”，而形参类型也符合PECS——<code>Function</code>函数式接口接受一个值（消费者），返回一个值（产出者）。</p>
<p>无限定的<code>?</code>在类型擦除时会彻底消失，连<code>Object</code>也不会留下，所以使用无限定的<code>?</code>会很奇怪，考虑<code>setFoo(?)</code>和<code>? getFoo()</code>，前者究竟可以传入什么呢？答案是除了<code>null</code>什么都不能传入。至于后者，针对一个毕竟可能真实存在的对象，Java不能粗暴地当返回值是<code>void</code>处理，也不能返回给你一个“什么都不是”的东西，所以只好返回作为终极超类的<code>Object</code>类型。</p>
<h2 id="7-部分术语中英文对照"><a href="#7-部分术语中英文对照" class="headerlink" title="7 部分术语中英文对照"></a>7 部分术语中英文对照</h2><p>特别标明一下以下几个术语，我发现不少地方错误地把泛型接口称为泛型类，把参数化类型与类型变量或类型参数（实参/形参）搞混。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">中文</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">泛型类</td>
<td style="text-align:center">Generic class</td>
<td style="text-align:center">声明了类型变量的类</td>
</tr>
<tr>
<td style="text-align:center">泛型接口</td>
<td style="text-align:center">Generic Interface</td>
<td style="text-align:center">声明了类型变量的接口</td>
</tr>
<tr>
<td style="text-align:center">参数化类型</td>
<td style="text-align:center">Parameterized type</td>
<td style="text-align:center">指代泛型类或有类型形参的泛型接口</td>
</tr>
<tr>
<td style="text-align:center">类型变量</td>
<td style="text-align:center">Type variable</td>
<td style="text-align:center">不那么严格的表达，来自类，接口，方法和构造器中的类型实参的声明</td>
</tr>
<tr>
<td style="text-align:center">类型形参</td>
<td style="text-align:center">Type parameter</td>
<td style="text-align:center">类比于形参</td>
</tr>
<tr>
<td style="text-align:center">类型实参</td>
<td style="text-align:center">Type argument</td>
<td style="text-align:center">类比于实参</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">用JMH测试FastClass和反射的效率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-13 16:07:41 / 修改时间：21:50:03" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:41+08:00">2020-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>现在来验证一下在Inflation优化下，Java反射和CGLib的<code>FastClass</code>哪个更高效。所用测试参数，JDK，JMH和JVM详情见输出结果。</p>
<h2 id="2-测试代码和输出结果"><a href="#2-测试代码和输出结果" class="headerlink" title="2 测试代码和输出结果"></a>2 测试代码和输出结果</h2><p>省略Bean类代码</p>
<p><code>FastClass</code>实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastClass;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastClass fastClass = FastClass.create(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastClassImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class[] noParam = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">        FastMethod getA = fastClass.getMethod(<span class="string">"getA"</span>, noParam);</span><br><span class="line">        FastMethod getB = fastClass.getMethod(<span class="string">"getB"</span>, noParam);</span><br><span class="line">        FastMethod getC = fastClass.getMethod(<span class="string">"getC"</span>, noParam);</span><br><span class="line">        FastMethod getD = fastClass.getMethod(<span class="string">"getD"</span>, noParam);</span><br><span class="line">        FastMethod setA = fastClass.getMethod(<span class="string">"setA"</span>, <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setB = fastClass.getMethod(<span class="string">"setB"</span>, <span class="keyword">new</span> Class[]&#123;Integer<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setC = fastClass.getMethod(<span class="string">"setC"</span>, <span class="keyword">new</span> Class[]&#123;Double<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setD = fastClass.getMethod(<span class="string">"setD"</span>, <span class="keyword">new</span> Class[]&#123;LocalDateTime<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj, noParam);</span><br><span class="line">        Object b = getB.invoke(originalObj, noParam);</span><br><span class="line">        Object c = getC.invoke(originalObj, noParam);</span><br><span class="line">        Object d = getD.invoke(originalObj, noParam);</span><br><span class="line"></span><br><span class="line">        Object clone = fastClass.newInstance();</span><br><span class="line">        setA.invoke(clone, <span class="keyword">new</span> Object[]&#123;a&#125;);</span><br><span class="line">        setB.invoke(clone, <span class="keyword">new</span> Object[]&#123;b&#125;);</span><br><span class="line">        setC.invoke(clone, <span class="keyword">new</span> Object[]&#123;c&#125;);</span><br><span class="line">        setD.invoke(clone, <span class="keyword">new</span> Object[]&#123;d&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>反射实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReflectionImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; oClass = originalObj.getClass();</span><br><span class="line"></span><br><span class="line">        Method getA = oClass.getMethod(<span class="string">"getA"</span>);</span><br><span class="line">        Method getB = oClass.getMethod(<span class="string">"getB"</span>);</span><br><span class="line">        Method getC = oClass.getMethod(<span class="string">"getC"</span>);</span><br><span class="line">        Method getD = oClass.getMethod(<span class="string">"getD"</span>);</span><br><span class="line">        Method setA = oClass.getMethod(<span class="string">"setA"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setB = oClass.getMethod(<span class="string">"setB"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setC = oClass.getMethod(<span class="string">"setC"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setD = oClass.getMethod(<span class="string">"setD"</span>, LocalDateTime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj);</span><br><span class="line">        Object b = getB.invoke(originalObj);</span><br><span class="line">        Object c = getC.invoke(originalObj);</span><br><span class="line">        Object d = getD.invoke(originalObj);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; constructor = oClass.getConstructor();</span><br><span class="line">        Object clone = constructor.newInstance();</span><br><span class="line">        setA.invoke(clone, a);</span><br><span class="line">        setB.invoke(clone, b);</span><br><span class="line">        setC.invoke(clone, c);</span><br><span class="line">        setD.invoke(clone, d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>基准性能测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">4</span>)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestBean TEST_BEAN = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cglib</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FastClassImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reflection</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果（部分）：</p>
<blockquote>
<p>JMH version: 1.25.2</p>
<p>VM version: JDK 1.8.0_251, Java HotSpot(TM) 64-Bit Server VM, 25.251-b08</p>
<p>Benchmark        Mode  Cnt     Score     Error  Units<br>Test.cglib       avgt    5  3614.397 ± 115.349  ns/op<br>Test.reflection  avgt    5  1502.978 ±  84.247  ns/op</p>
</blockquote>
<p>反射完胜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">CGLib之Enhancer小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:07:03" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:03+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 14:13:04" itemprop="dateModified" datetime="2020-10-09T14:13:04+08:00">2020-10-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考资料：<a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">CGLib: The Missing Menual</a></p>
<h2 id="1-不要用非静态内部类创建Callback或者保存其为静态变量"><a href="#1-不要用非静态内部类创建Callback或者保存其为静态变量" class="headerlink" title="1 不要用非静态内部类创建Callback或者保存其为静态变量"></a>1 不要用非静态内部类创建Callback或者保存其为静态变量</h2><p>许多国内博客明显也参考了这份资料，然而他们都忽略了一个资料作者提及的重要事项：出于CGLib的实现原理，在创建<code>Enhancer</code>的类中使用匿名内部类创建<code>Callback</code>是危险的。资料作者使用匿名内部类只是为了简化演示代码。</p>
<p><strong>静态字段可以成为所谓的GC Root</strong>。</p>
<p><code>Enhancer</code>对象会为它的每个<code>Callback</code>创建一个私有的，静态的字段，而<code>Callback</code>本身在工作时，也会根据情况在<code>Enhancer</code>对象中加入静态字段。如果以匿名内部类创建<code>Callback</code>实例，由于非静态匿名内部类隐式地包含对外部类实例的引用，这会造成外部类实例，<code>Enhancer</code>对象和<code>Callback</code>对象之间交错的相互引用，静态字段加上循环引用非常容易妨碍到GC回收，这种情况下<code>Callback</code>对象<strong>永远</strong>不会被回收，这对于内存管理来说非常危险。</p>
<p>在CGLib的使用中用匿名内部类实现<code>Callback</code>的诱惑，相比在JDK动态中使用匿名内部类实现<code>InvocationHandler</code>更大，<code>InvocationHandler</code>通常需要包装被代理实例作为字段，在匿名内部类里做这一点显得非常冗长，而CGLib的代理对象是被代理对象的子类，能通过在<code>create()</code>方法中传入构造器形参类型和实参构造出完全代理被代理对象的实例。</p>
<p>普通的成员内部类也隐式地包含对外部类实例的引用，因此和非静态匿名内部类有同样的危险，但成员内部类的引用容易获得，至少能够管理（虽然这么做会非常麻烦且毫无道理），而匿名内部类则不能。</p>
<p>如果要用匿名内部类实现<code>Callback</code>，需要小心分辨，或者，更好的做法，直接用Lambda表达式。</p>
<h2 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2 测试代码"></a>2 测试代码</h2><p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal0</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal0 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal1 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divided</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallBack</code>实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Author: Illuminated Worm</span><br><span class="line"> * Version: 1.00</span><br><span class="line"> * Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CallBackDemo implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; objects.length; i++) &#123;</span><br><span class="line">            objects[i] &#x3D; (Integer) objects[i] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.Calculator;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.CallBackDemo;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackHelper;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer b = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator(<span class="string">"raw"</span>);</span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unit0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Calculator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        CallbackHelper callbackHelper = new CallbackHelper(Calculator.class, new Class[0]) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"cal1"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CallBackDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">        enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line"></span><br><span class="line">        Class[] argsType = &#123;String<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">        String[] arguments = &#123;<span class="string">"Proxy"</span>&#125;;</span><br><span class="line">        Calculator calculator = (Calculator) enhancer.create(argsType, arguments);</span><br><span class="line"></span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Calculator cal0 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0<br>Calculator cal1 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
<p>Calculator cal0 Proxy<br>plus: 12<br>minus: -4<br>times: 32<br>divided: 0<br>Calculator cal1 Proxy<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
</blockquote>
<h2 id="3-流程小结，Callback类鉴别"><a href="#3-流程小结，Callback类鉴别" class="headerlink" title="3 流程小结，Callback类鉴别"></a>3 流程小结，Callback类鉴别</h2><p>现在根据使用流程逐个总结使用细节。</p>
<p>在创建<code>Enhancer</code>对象后一定要使用<code>setSuperClass()</code>方法传入被代理类的类对象，即使<code>CallbackHelper</code>看起来也传入了被代理类的类对象，它不会为你完成这一步。</p>
<p><code>CallbackHelper</code>是<code>CallbackFilter</code>的默认实现类，设置过滤器的主要目的是将方法调用分发和具体的方法实现解耦，在这里做的工作基本就是根据方法名称调用不同的<code>Callback</code>。</p>
<p>使用<code>CallbackHelper</code>的情况下可以更简洁地为<code>Enhancer</code>设置<code>Callback</code>。如果不打算解耦分发逻辑和方法实现的话，或者分发逻辑较简单可以并入<code>Callback</code>，那么<code>CallbackHelper</code>并非必须的。</p>
<p><code>Callback</code>有如下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FixedValue</td>
<td style="text-align:center">简单地用另一个对象（通常是固定的）代替原本的返回值</td>
</tr>
<tr>
<td style="text-align:center">InvocationHandler</td>
<td style="text-align:center">大致与JDK动态代理用的InvocationHandler一样</td>
</tr>
<tr>
<td style="text-align:center">MethodInterceptor</td>
<td style="text-align:center">最全面，相比InvocationHandler多了一个MethodProxy类型的参数</td>
</tr>
<tr>
<td style="text-align:center">LazyLoader</td>
<td style="text-align:center">FixedValue的懒加载版，用于返回昂贵的对象</td>
</tr>
<tr>
<td style="text-align:center">Dispatcher</td>
<td style="text-align:center">每次方法调用都会重新生成返回对象，用于不改变对类的引用而改变其实现时</td>
</tr>
<tr>
<td style="text-align:center">ProxyRefDispatcher</td>
<td style="text-align:center">用于调用类的另一个方法</td>
</tr>
<tr>
<td style="text-align:center">NoOp</td>
<td style="text-align:center">使用被代理类原本的方法</td>
</tr>
</tbody>
</table>
</div>
<p><code>ProxyRefDispatcher</code>和<code>NoOp</code>基本上是用在解耦后的分发逻辑里的。<code>MethodInterceptor</code>虽然全面，但其他<code>Callback</code>更高效。</p>
<p><code>MethodInterceptor</code>提供的<code>MehtodProxy</code>对象有<code>invoke()</code>和<code>invokeSuper()</code>两个方法，前者用于对<strong>别的对象</strong>调用方法，后者才是对当前对象调用父类（被代理类）的方法。如果对当前对象使用<code>invoke()</code>将会导致死循环！</p>
<p>上文也提到过，CGLib的代理类是被代理类的子类，能轻易地完全摆脱被代理类实例，这可以在调用<code>create()</code>方法时完成。JDK动态代理不便于也不适宜完全取代被代理类实例。</p>
<p><code>Enhancer</code>作为CGLib中的重要使用对象，其API还是比较清晰明白的。CGLib适合于对未实现接口的类进行动态代理，但它创建新类的速度并没有JDK动态代理快，因此在Spring这种有数量不多的单例对象的情景里，只要目标实现了接口，Spring就选择Java原生代理。并且CGLib的动态代理的功能并非完全覆盖JDK动态代理——出于继承机制的限制，CGLib动态代理不能作用于<code>final</code>方法。</p>
<p>CGLib的<code>FastClass</code>通过直接对生成字节码来做到比反射更快。反射的底层是基于C语言的原生方法，其效率固然不那么快，然而HotSpot这样的现代JVM中有着inflation优化机制：反射JNI调用超过一定次数（默认为15）后，便会生成本地的字节码。在这种情况下，反射的效率劣势得到了一定程度的弥补，所以CGLib的<code>FastClass</code>也不是那么推荐了。悲伤的故事^ ^。</p>
<p>CGLib的主要问题在于，它会生成许多新类，消耗堆空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">SpringAOP小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:06:30" itemprop="dateCreated datePublished" datetime="2020-09-13T16:06:30+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-19 13:28:30" itemprop="dateModified" datetime="2020-09-19T13:28:30+08:00">2020-09-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1 测试代码"></a>1 测试代码</h2><p>导入jar包省略。</p>
<p>Spring已配置包扫描，加入aspectj支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>“DAO”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Your input: "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“Service”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.annotation.WormCut;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDao;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDao</span><span class="params">(TestDaoImpl testDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDao = testDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m0 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@WormCut</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m1 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WormCut &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Aspect：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javasm.service.TestServiceImpl.m0(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.javasm.annotation.WormCut)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Execution of method "</span> + pjp.getSignature().getName() + <span class="string">" took "</span> + (end - start) + <span class="string">"ms."</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Before advice triggered."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"JoinPoint kind: "</span> + jp.getKind());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Method signature: "</span> + jp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"Args: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object arg : jp.getArgs()) &#123;</span><br><span class="line">            System.out.print(arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Target object hashcode: "</span> + jp.getTarget().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Proxy object hashcode: "</span> + jp.getThis().hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(jp.getStaticPart().toLongString());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"cut0()"</span>, returning = <span class="string">"obj"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(JoinPoint jp, Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterReturning advice triggered."</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"There is no returning Obj."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"cut0()"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwAdvice</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterThrowing advice triggered."</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"After advice triggered."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationBeforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Annotation pointcut success."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.service.TestService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">init</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        TestService testService = applicationContext.getBean(TestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        testService.m0(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">        testService.m1(<span class="string">"Hello Annotation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Before advice triggered.<br>JoinPoint kind: method-execution<br>Method signature: m0<br>Args: Hello Spring!<br>Target object hashcode: 790094605<br>Proxy object hashcode: -1294849058<br>execution(public abstract void com.javasm.service.TestService.m0(java.lang.String))</p>
<p>method m0 triggered.<br>Your input: Hello Spring!</p>
<p>AfterReturning advice triggered.<br>There is no returning Obj.</p>
<p>After advice triggered.</p>
<p>Execution of method m0 took 1007ms.</p>
<p>Annotation pointcut success.</p>
<p>method m1 triggered.<br>Your input: Hello Annotation!</p>
</blockquote>
<h2 id="2-流程小结，通知注释鉴别"><a href="#2-流程小结，通知注释鉴别" class="headerlink" title="2 流程小结，通知注释鉴别"></a>2 流程小结，通知注释鉴别</h2><p>将Contoller，Service和DAO等关键对象交给Spring管理，再辅以AspectJ，对于使用者来说，从亲手实现动态代理和在各处用代理对象替换被代理对象中解放出来，控制反转让施行真正的面向切面编程成为现实。（要注意的是SpringAOP采用的这种实现方式并不是唯一的，如AspectJ本身是在编译时通过专用编译器生成字节码来实现的）</p>
<p>需要声明切面，创建一个类，注释以<code>Aspect</code>并将其注入Spring。</p>
<p>然后建立空方法，以<code>@Pointcut</code>注释来声明需要切入处，主要方式有：</p>
<ol>
<li><p>execution方式，大致格式为“[返回值类型]空格[包|类|方法的全限定名]（形参类型）”。其中返回值和全限定名都可以以*作为通配符，形参类型可以写作“..”以省略。</p>
</li>
<li><p>@annotation方式，将定位反转，通过切入处的指定注释来找到切入处，注释必须用全限定名。</p>
</li>
</ol>
<p>最后建立方法，声明通知时机，通知时机的选择可见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">注释</th>
<th style="text-align:center">调用时机</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@Before</td>
<td style="text-align:center">切入方法调用前</td>
<td style="text-align:center">可以从JoinPoint中获得除了切入方法返回值外的多数信息</td>
</tr>
<tr>
<td style="text-align:center">@AfterReturning</td>
<td style="text-align:center">切入方法返回后</td>
<td style="text-align:center">在注释中赋值returning，可以获得切入方法返回值</td>
</tr>
<tr>
<td style="text-align:center">@AfterThrowing</td>
<td style="text-align:center">切入方法抛出异常后</td>
<td style="text-align:center">在注释中赋值throwing，可以获得切入方法抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">@After</td>
<td style="text-align:center">切入方法完成后</td>
<td style="text-align:center">不能获得什么信息</td>
</tr>
<tr>
<td style="text-align:center">@Around</td>
<td style="text-align:center">囊括以上</td>
<td style="text-align:center">最强大的通知，可以以ProceedingJoinPoint的proceed()方法划分切入方法执行前后。</td>
</tr>
</tbody>
</table>
</div>
<p>通过给@Around注释的方法中的<code>proceedingJoinPoint.proceed()</code>语句围绕try-catch-finally代码块，@Aroud注释的方法就能囊括所有其他调用时机。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">从Mybatis看动态代理和设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-08 01:04:01" itemprop="dateCreated datePublished" datetime="2020-09-08T01:04:01+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-14 22:48:36" itemprop="dateModified" datetime="2020-09-14T22:48:36+08:00">2020-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文基于JDK 1.8.0_261，Mybatis 3.5.5。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><ol>
<li>接口规定方法，具体的实现类继承（inherit）接口，实现方法。这个过程就像某人签署了一份有要求的协议，遵守了某种约定。</li>
<li>向上转型，实例化子类对象，将其声明为超类类型。在Java中接口不能被实例化，但可以在向上转型时用作声明。</li>
<li>Java的反射机制赋予程序员在运行时分析和操作类的能力。</li>
</ol>
<p>像这样的基础知识在初学时都会感觉有些不知所云，它们过于抽象，即使能完全理解其字面，也会因为缺乏对实际运用情景的了解而体会浅显。</p>
<p>许多东西就像各种专业工具，它叫什么和包含了什么概念并不是首要的，首要的是它能做什么，某些情况下知道它不能做什么也非常重要。</p>
<p>反射机制尚可联想出一些具有通用性的简单工具类来加以实践，而类似1，2点则彻底令人一头雾水，这是因为它们的概念和实现往往都和设计模式有关。Mybatis正是运用到了相关的设计模式，它毫无疑问是一个具体，有效，好用的工具——它实现了这样的目的：以更标准（以DTD模板和库内十分硬编码的解析方式约束配置文件写法）和更便捷的方式处理持久化层代码（可能需要搭配第三方工具和插件）。借由理解这个工具的原理，可以解惑。但在此之前先复习一下动态代理。</p>
<h2 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h2><p>假设现在存在这样的需求：有相当数目的遗留代码，现在需要对其中的方法附加新功能，而你被要求不能改动遗留代码（更可能的是你自己就不想干牵一发而动全身的恐怖事情）。那么你需要的就是所谓的“非侵入式代码”，具体的做法是，写一个新的类，将旧类作为成员变量包进来，在新类的方法中调用旧类的方法并附加你的新功能。十分易懂。专门自己完全手写这样的类就是所谓的静态代理。</p>
<p>动态代理和静态代理的本质都一样，所谓的动态就是通过找到一种既定的模式，让程序自己处理方法调用那一步，这样面对几十个类就不需要写几十个代理类了，而这份“既定的模式”就依赖接口来达成，程序通过接口来得知有哪些方法，<strong>Java原生动态代理</strong>的前提就是，<strong>被代理的类应该有其接口</strong>。</p>
<h3 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h3><p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Interface of simple calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Impelement of simple calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: the hanlder for calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorHanlder</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatorHanlder</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"Now we intercept method "</span>);</span><br><span class="line">        strBuilder.append(method.getName()).append(<span class="string">"("</span>);</span><br><span class="line">        String prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (Parameter parameter : method.getParameters()) &#123;</span><br><span class="line">            strBuilder.append(prefix);</span><br><span class="line">            prefix = <span class="string">", "</span>;</span><br><span class="line">            strBuilder.append(parameter.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        strBuilder.append(<span class="string">"), parameters = ["</span>);</span><br><span class="line">        prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            strBuilder.append(prefix);</span><br><span class="line">            prefix = <span class="string">", "</span>;</span><br><span class="line">            strBuilder.append(arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        strBuilder.append(<span class="string">"], we are able to do things as we wish."</span>);</span><br><span class="line">        System.out.println(strBuilder.toString());</span><br><span class="line">        Integer result = (Integer) method.invoke(target, args) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Let's check out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result of 3 + 7 ?"</span>);</span><br><span class="line">        CalculatorImpl calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">        <span class="keyword">int</span> result0 = calculator.add(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"result without proxy: "</span> + result0);</span><br><span class="line"></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Calculator<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">CalculatorHanlder</span>(<span class="title">calculator</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = ((Calculator) proxy).add(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"result with proxy: "</span> + result1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>result of 3 + 7 ?<br>result without proxy: 10<br>Now we intercept method add(int arg0, int arg1), parameters = [3, 7], we are able to do things as we wish.<br>result with proxy: 11</p>
</blockquote>
<h3 id="2-2-就是这样"><a href="#2-2-就是这样" class="headerlink" title="2.2 就是这样"></a>2.2 就是这样</h3><p>如上所见，对代理对象调用方法时，它就会“拦截”到这份调用，把代理对象，被调用方法和参数都呈递出来。在这里，我用反射分析并输出了“拦截”到的方法的签名，还为其计算结果增加了1，可以做的事情十分自由，尤其是知道被代理类的具体情况，可以根据方法名“拦截”特定方法而对其他方法“放行”，可以判断对参数的强制类型转换是否安全。至于代理对象，典型的场景是代理对象存储在集合内，对集合的操作都是对代理对象的操作，你会想要处理代理对象而不是被代理对象。</p>
<p><code>Proxy</code>实例加上处理器就是静态代理中代理类的等价物，只是凭借接口的约定，达到了美妙的编程体验（当然可能也增加了一些反射机制的常见苦恼，通用性是有代价的），并没有什么魔法。</p>
<p>在调试中可以看到proxy实例的类型是<code>$Proxy0</code>，可以让JVM保留它的类文件。在我这里是这样做的，在程序开头加入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
<p>或设置JVM参数“-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true”。注意，<code>ProxyGenerator</code>在不同的JDK版本中可能位于不同的包下。</p>
<p>反编译$Proxy0.class能直观地明白为什么动态代理只能依赖接口而不是类，因为$Proxy0已经扩展了<code>Proxy</code>。并且可以看出这个类的目的，非常简单而贴心，它巨细无遗地为你拦截了传入接口中的方法（包括继承而来的方法），把参数传入给处理器的<code>invoke()</code>方法，并对返回值进行强制类型转换。从这些重复工作中解脱出来正是使用动态代理的魅力。</p>
<p>如果只是这样，感觉动态代理类似乎也并不是那么有用，那么可以通过Mybatis的Mapper再来体会一下。</p>
<h2 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3 Mybatis"></a>3 Mybatis</h2><p>在进入<code>getMapper()</code>方法之前，有必要简单领略一下Mybatis的整个流程，只是从较高的抽象层次讲述，不会从源代码中一条一条的分析。典型的使用流程如下图：</p>
<img src="/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Mybatis%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" class="">
<ol>
<li>以mybatis-config.xml文件创建流。</li>
<li>创建<code>SqlSessionFactoryBuilder</code>实例，调用用它的<code>builder()</code>，将上面的输入流传入，获取<code>SqlSessionFactory</code>对象。</li>
<li>调用<code>SqlSessionFactory</code>实例的<code>openSession()</code>方法获取<code>SqlSession</code>对象。</li>
<li>调用<code>SqlSession</code>实例的<code>getMapper()</code>方法，将某个DAO层接口的<code>Class</code>对象传入，获取代理对象。</li>
</ol>
<p>这个流程乍看起来似乎很麻烦，为什么要分割成这么多步呢？有很多理由支持这样的做法。</p>
<h3 id="3-1-应该快速死亡的SqlSessionFactoryBuilder"><a href="#3-1-应该快速死亡的SqlSessionFactoryBuilder" class="headerlink" title="3.1 应该快速死亡的SqlSessionFactoryBuilder"></a>3.1 应该快速死亡的SqlSessionFactoryBuilder</h3><p>如流程图所示，<code>SqlSessionFactoryBuilder</code>实例的唯一目的是创建出一个<code>Configuration</code>类型的实例，<code>Configuration</code>对象可以认为是对mybatis-config.xml的映射，如果你查看源代码，就会发现这个类整整有50个字段！并且某些字段还是包含更多数据的集合！</p>
<p>如此多的字段需要装填，这些数据还需要颇为麻烦的XML文本解析——嵌套的标签，判错，赋予缺省值……因此Mybatis的实现者对此采用了构建器模式，即便如此，代码层层往下看起来仍然十分麻烦，为普通JavaBean类编写的构建器与之相比可是说是小巫见大巫了。不过我们现在并不关心类库程序员的烦心事。</p>
<p>作为用户，我们应该想到的是，解析文本从来都是一件麻烦事，除了具体实现，还有这些实现所占用的资源。严格地讲，解析mybatis-config.xml所用的是一个有限状态机，它颇为昂贵，而解析得到的<code>Configuration</code>相比之下不过是更单纯的一系列数据结构。合情合理地，解析资源应该被尽快释放。</p>
<h3 id="3-2-我只是要发起会话而已……SqlSessionFactory"><a href="#3-2-我只是要发起会话而已……SqlSessionFactory" class="headerlink" title="3.2 我只是要发起会话而已……SqlSessionFactory"></a>3.2 我只是要发起会话而已……SqlSessionFactory</h3><p>从源代码来看，<code>SqlSessionFactory</code>不过包装着仅有的一个<code>Configuration</code>对象，有数个私有的较复杂方法和一系列公开的<code>openSession()</code>方法的简单重载，然而这就是工厂模式的简单形式。大多数时候，用户只是想要简单地想要一个<code>SqlSession</code>罢了，并不想填写那些可选参数。于是这个工作被交由几个公开方法承担，它们填写符合直觉与约定的缺省值（例如，对于SQL语句是否自动提交，你并不想每次都去填写一个布尔值），调用那些看起来就麻烦的私有方法，将结果传递给用户。</p>
<p>从用户体验来看，这个设计模式的效果是良好的。</p>
<p><code>SqlSessionFactory</code>中包含得来不易的那个<code>Configration</code>对象，应该把它做成单例模式里的常量反复使用，当然这在Spring框架里这是不需要自己实现的。</p>
<p><code>SqlSessionFactoryBuilder</code>对象在完成它的任务后不再被引用，最终将被GC回收掉，<code>SqlSessionFactory</code>对象作为枚举实例的字段保留下来。一切正如Mybatis官方建议的那样。</p>
<h3 id="3-3-不是Connection而是SqlSession"><a href="#3-3-不是Connection而是SqlSession" class="headerlink" title="3.3 不是Connection而是SqlSession"></a>3.3 不是Connection而是SqlSession</h3><p><code>SqlSession</code>对象看起来像是<code>Connection</code>和<code>&lt;T extends Statement&gt;</code>的综合，可以向它传入Sql语句和参数，它与数据库连接并执行Sql语句。它的名字容易让人想到Web中的Session，Session是计算机科学的一个基本概念，而<code>SqlSession</code>和Web中的Session都可以看作此概念在特定领域的实现。</p>
<p>值得一提的是Mybatis自带了数据库连接池的实现，当<code>SqlSession</code>对象调用<code>close()</code>方法时，追踪看下去似乎就是对应的<code>Connection</code>对象调用<code>close()</code>方法，但其实这里仍然用到了代理模式，这份调用最终会被<code>PooledConnection</code>“拦截”，将连接放回连接池而不是真正的关闭它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">        <span class="keyword">this</span>.proxyConnection = (Connection)Proxy.newProxyInstance(Connection<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">IFACES</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.checkConnection();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.realConnection, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PooledConnection</code>中有一个比较令人迷惑的做法，它实现了<code>InvocationHandler</code>，那么理所当然它只是处理器而已，但实现者似乎是为了方便，在这个类的构造器中就用当前实例创建了动态代理实例，也就是说，<code>PooledConnection</code>的实例包含了一个与自身互相引用的字段。在Mybatis中的其他处理器类中没有采用这种做法，</p>
<p>总之，这种做法也许不失为将<code>Proxy</code>实例和处理器一体化的可行做法。</p>
<h3 id="3-4-getMapper"><a href="#3-4-getMapper" class="headerlink" title="3.4 getMapper()"></a>3.4 getMapper()</h3><p>对<code>SqlSessionFactory</code>的<code>getMapper()</code>方法往下追踪，可以在<code>MapperRegistry</code>类中发现如下代码（省略了大部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</span><br><span class="line">        <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>KnownMappers是解析XML配置文件得来的<code>HashMap</code>，其键来自mapper配置里的namespace，即用户配置的接口，通过<code>getMapper()</code>方法传入的<code>Class</code>对象来匹配并获得对应的代理工厂。</p>
<p>我们最终可以在<code>MapperProxy</code>中找到关键的方法调用，它进行了许多小心翼翼的判断，传入的类是否为<code>Object</code>，调用的方法是否为默认方法（有方法体的接口方法），针对性进行各自适宜的处理，最终，它用接口名和方法名去<code>Configuration</code>中匹配找到解析语句标签得到的相关对象，用以生成Sql语句并调用<code>SqlSession</code>中的对应方法执行。</p>
<h2 id="4-不限于斯，第三方动态代理"><a href="#4-不限于斯，第三方动态代理" class="headerlink" title="4 不限于斯，第三方动态代理"></a>4 不限于斯，第三方动态代理</h2><p>就像之前提到的，Java原生动态代理需要一个前提，被代理类实现了某个接口。可是为Bean类提供接口并不是普遍的做法，那么Mybatis如何动态生成和填充相应的Bean对象呢，如果使用反射，那么要做的工作是：查找Bean类的无参构造器，改变其可访问性，查找字段，根据字段名查找Setter方法，改变其可访问性，构造实例，调用Setter方法……</p>
<p>我们会发现，即时忽略需要接口的前置条件，Java原生代理似乎对于当前的需求仍不太适宜：Java原生动态代理可以很快地生成新类，可是反射虽然说不上慢，却也不快，反射所须的上述一系列“周全”的工作拖慢了后续执行。为此，Mybatis中用了第三方工具CGLib来解决对Bean类代理问题，CGLib是基于继承机制和第三方ASM框架的，ASM框架加载被代理类的字节码文件，加以修改生成子类，靠更快的后续执行胜过反射。</p>
<p><strong>至少，曾经是这样的，现在则不一定。</strong>认为Java的反射效率低其实是历史遗留色彩很重的观点，在现在的许多性能基准测试中，在执行次数大的前提下，反射与第三方代替类库的效率相差无几。</p>
<p>原生工具和第三方工具并没有什么优劣之别，只是侧重点不同。此消彼长，客观规律罢了，实际应用中的重点在于选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/05/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9C%8BString%E7%9A%84%E5%8A%A0%E6%B3%95%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9C%8BString%E7%9A%84%E5%8A%A0%E6%B3%95%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">从字节码文件看String的加法重载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 15:34:20" itemprop="dateCreated datePublished" datetime="2020-09-05T15:34:20+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-12 19:05:58" itemprop="dateModified" datetime="2020-09-12T19:05:58+08:00">2020-09-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇<a href="https://illuminatedworm.github.io/2020/08/19/%E7%94%A8Optional%E5%81%9A%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%A4%E5%88%99/" target="_blank" rel="noopener">用Optional做逻辑判断的实例两则</a>提及了<code>StringBuilder</code>和<code>String</code>的用法细节，关于<code>append()</code>方法和<code>+</code>运算符的问题其实是《Java编程思想》专门用一小节论述过的。不过仍然值得亲自验证一番。</p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrPlusTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder mainComp = <span class="keyword">new</span> StringBuilder(<span class="string">"主句子"</span>);</span><br><span class="line">        String secondComp = <span class="string">"组件2"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(mainComp.append(<span class="string">"组件1"</span>).append(secondComp).append(<span class="string">"组件2"</span>));</span><br><span class="line">        mainComp = <span class="keyword">new</span> StringBuilder(<span class="string">"主句子"</span>);</span><br><span class="line">        System.out.println(mainComp.append(<span class="string">"组件1"</span> + secondComp + <span class="string">"组件2"</span>)); <span class="comment">// don't do this.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出结果：</p>
<blockquote>
<p>主句子组件1组件2组件2<br>主句子组件1组件2组件2</p>
</blockquote>
<p>输出结果一致。</p>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p><a href="https://github.com/zxh0/classpy" target="_blank" rel="noopener">所用工具</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2020/09/05/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%9C%8BString%E7%9A%84%E5%8A%A0%E6%B3%95%E9%87%8D%E8%BD%BD/bytecode.png" class="" title="bytecode"></h2><p>可以清楚地看到，对于纯粹使用<code>StringBuilder</code>的方式，从17行至28行，就是三个直接了当的相关变量和<code>append()</code>方法调用。</p>
<p>而对于在<code>append()</code>中使用<code>+</code>运算符的方式，从48行到72行，一个新的<code>StringBuilder</code>对象被创建出来（并不是重置主句子导致的），进行了从17行至28行相同的操作，而后这个对象被<code>toString()</code>方法转换成<code>String</code>对象，最终被<code>append()</code>方法组装进mainComp。</p>
<h2 id="并没有什么魔法……"><a href="#并没有什么魔法……" class="headerlink" title="并没有什么魔法……"></a>并没有什么魔法……</h2><p><code>String</code>对象是不可变的，它引用的数据是常量，Java只是为之重载了<code>+</code>运算符，当用<code>+</code>和<code>+=</code>拼装字符串时，无名的<code>StringBuilder</code>对象在幕后工作着。<code>String</code>类的许多方法也是类似的，用到和<code>StringBuilder</code>类似的原理，先将转换字符串为数组再作处理，并且没有<code>StringBuilder</code>高效。</p>
<p>像IDEA这样的IDE是会警告<code>+</code>运算符的不恰当用法的，但是类似这样的如下的写法则不会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D; ...</span><br><span class="line">do something else</span><br><span class="line">str +&#x3D; ...</span><br><span class="line">do something else</span><br><span class="line">str +&#x3D; ...</span><br><span class="line">do something else</span><br><span class="line">str +&#x3D; ...</span><br><span class="line">more code like this...</span><br></pre></td></tr></table></figure>
<p>如此代码会产生许多看不见且毫无必要的对象创建和方法调用。最终，JIT编译器也许能优化，也许不能，这不是重点，重点是应该从一开始就避免不恰当的代码。</p>
<p>考虑到操作“同一条”字符串是非常常见的工作，且很可能像上面一样操作多次，而又得不到IDE的提示，理应知晓如下结论：</p>
<ol>
<li>对字符串进行较复杂操作时，从一开始就使用<code>StringBuilder</code>，或是需要线程安全时使用<code>StringBuffer</code>。</li>
<li>为字符串重载的<code>+</code>运算符虽然不坏，但表现也不够智能，应该只在简单操作时使用。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/19/%E7%94%A8Optional%E5%81%9A%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%A4%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/19/%E7%94%A8Optional%E5%81%9A%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B8%A4%E5%88%99/" class="post-title-link" itemprop="url">用Optional做逻辑判断的实例两则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-19 23:06:38" itemprop="dateCreated datePublished" datetime="2020-08-19T23:06:38+08:00">2020-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-25 21:24:32" itemprop="dateModified" datetime="2020-09-25T21:24:32+08:00">2020-09-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>原生地实现分页有条件查询的DAO层代码，需要根据情况组装SQL语句。除了肯定有效的当前页码和每页条目量两个参数，还有两个可能为<code>null</code>或者<code>&quot;&quot;</code>的<code>String</code>参数，大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入了参数currPage，pageSize，包含name和desc字段的goods。desc为模糊查询条件。</span></span><br><span class="line"><span class="comment">// ……省略部分</span></span><br><span class="line">String sql = <span class="string">"SELECT goods_id, goods_name, goods_price, goods_quantity, goods_desc FROM goods_info"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isWhere = <span class="keyword">true</span>;</span><br><span class="line">        List params = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (goods.getName() != <span class="keyword">null</span> &amp;&amp; !queryUser.getDesc().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isWhere) &#123;</span><br><span class="line">                sql += <span class="string">" WHERE "</span>;</span><br><span class="line">                isWhere = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sql += <span class="string">" AND "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sql += <span class="string">" goods_name = ? "</span>;</span><br><span class="line">            params.add(goods.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(goods.getName() != <span class="keyword">null</span> &amp;&amp; !goods.getDesc().equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isWhere) &#123;</span><br><span class="line">                sql+=<span class="string">" WHERE "</span>;</span><br><span class="line">                isWhere = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sql+=<span class="string">" AND "</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sql += <span class="string">" goods.Desc LIKE ? "</span>;</span><br><span class="line">            params.add(<span class="string">"%"</span> + queryUser.getUserRemark() + <span class="string">"%"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sql += <span class="string">"limit "</span> + (currPage-<span class="number">1</span>) * pageSize + <span class="string">","</span> + pageSize;</span><br><span class="line"><span class="comment">// ……省略部分</span></span><br></pre></td></tr></table></figure>
<p>可以看到条件判断语句嵌套，且需要引入一个显得孤立的<code>boolean</code>值进行辅助。如果用<code>Optional</code>对<code>name</code>和<code>desc</code>进行处理，整个结构就会清晰很多，更改后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入了参数currPage，pageSize，包含name和desc字段的goods。desc为模糊查询条件。</span></span><br><span class="line"><span class="comment">// ……省略部分</span></span><br><span class="line">StringBuilder sqlStmt = <span class="keyword">new</span> StringBuilder(<span class="string">"SELECT goods_id AS `id`, goods_name AS `name`, goods_price AS `price`, goods_quantity AS `quantity`, goods_desc AS `desc` FROM goods_info"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flagName = Optional.ofNullable(goods.getName())</span><br><span class="line">                .filter(s -&gt; !s.isEmpty())</span><br><span class="line">                .isPresent();</span><br><span class="line">        <span class="keyword">boolean</span> flagDesc = Optional.ofNullable(goods.getDesc())</span><br><span class="line">                .filter(s -&gt; !s.isEmpty())</span><br><span class="line">                .isPresent();</span><br><span class="line">        <span class="keyword">if</span> (flagName || flagDesc)</span><br><span class="line">            sqlStmt.append(<span class="string">" WHERE"</span>);</span><br><span class="line">        <span class="keyword">if</span> (flagName)</span><br><span class="line">            sqlStmt.append(<span class="string">" goods_name = "</span>).append(<span class="string">"'"</span>).append(goods.getName()).append(<span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">if</span> (flagName &amp;&amp; flagDesc)</span><br><span class="line">            sqlStmt.append(<span class="string">" AND"</span>);</span><br><span class="line">        <span class="keyword">if</span> (flagDesc)</span><br><span class="line">            sqlStmt.append(<span class="string">" goods_desc LIKE "</span>).append(<span class="string">"'%"</span>).append(goods.getDesc()).append(<span class="string">"%'"</span>);</span><br><span class="line"></span><br><span class="line">        sqlStmt.append(<span class="string">" LIMIT "</span>).append((currPage - <span class="number">1</span>) * pageSize).append(<span class="string">","</span>).append(pageSize);</span><br><span class="line"><span class="comment">// ……省略部分</span></span><br></pre></td></tr></table></figure>
<p>逻辑结构简洁，版面美观。同时换用了<code>StringBuilder</code>组装SQL语句，注意此时没有使用<code>?</code>占位符，降低了抗SQL注入能力。</p>
<p>顺便提及一个<code>StringBuilder</code>的用法问题，见下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlStmt.append(<span class="string">" goods_desc LIKE '%"</span>).append(goods.getDesc()).append(<span class="string">"%'"</span>);</span><br><span class="line">sqlStmt.append(<span class="string">" goods_desc LIKE '%"</span> + goods.getDesc + <span class="string">"%'"</span>);</span><br></pre></td></tr></table></figure>
<p>这样两行代码的最终效果是完全一样，可读性上或许也相差无几，但具体实现有甚大差别：</p>
<ol>
<li>第一行代码中，没有任何<code>String</code>对象被创建，这些字符串直截了当地以其 interned 版本被传入<code>sqlStmt</code>以进行组装。</li>
<li>第二行代码中，具体过程简直一团糟！一个新的<code>StringBuilder</code>对象被创建出来，那三个字符串被传入其中组装，然后这个无名的新对象调用<code>toString()</code>方法得到一个<code>String</code>对象，最终这个<code>String</code>对象被写入<code>sqlStmt</code>。</li>
</ol>
<p>也许真实运行效率还需要考虑运行环境，但仍可以毫不客气地说，请避免使用第二种写法。</p>
<h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>第二个例子要简单得多，同样也是原生地实现，例一中功能对应的Controller层，须对网页传入参数的判断和赋值，不再列出改进前代码，改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> currPage = Optional.ofNullable(req.getParameter(<span class="string">"currPage"</span>))</span><br><span class="line">                .filter(s -&gt; s.matches(<span class="string">"^[\\d]&#123;1,9&#125;$"</span>)) <span class="comment">// Pattern实例创建成本较高，实际情况中应创建常量供反复使用。</span></span><br><span class="line">                .map(Integer::parseInt)</span><br><span class="line">                .orElse(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> pageSize = Optional.ofNullable(req.getParameter(<span class="string">"pageSize"</span>))</span><br><span class="line">                .filter(s -&gt; s.matches(<span class="string">"^[\\d]&#123;1,9&#125;$"</span>)) <span class="comment">// 同上一注释。</span></span><br><span class="line">                .map(Integer::parseInt)</span><br><span class="line">                .orElse(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>Controller层中常见的处理流程：</p>
<ol>
<li>从HttpRequest对象中获取指定名称的参数。</li>
<li>初步判断：此参数是否为<code>null</code>。</li>
<li>进一步判断：此参数是否符合某个较复杂的条件（在此处是是否为阿拉伯数字字符）。</li>
<li>对此参数进行类型转换。</li>
<li>如果此参数不通过判断，赋予它一个特定值（可用的有效默认值，或者用于后续判错的特殊值）。</li>
</ol>
<p>用<code>Optional</code>和此类中的链式方法来处理，最好不过，优点显而易见，再何况，有谁可以拒绝链式方法的诱惑呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/09/%E9%87%8D%E6%B8%A9%E8%A1%A5%E7%A0%81%E5%92%8C%E5%8F%91%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/09/%E9%87%8D%E6%B8%A9%E8%A1%A5%E7%A0%81%E5%92%8C%E5%8F%91%E6%83%B3/" class="post-title-link" itemprop="url">重温补码和发想</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 14:27:04" itemprop="dateCreated datePublished" datetime="2020-08-09T14:27:04+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-10 01:25:23" itemprop="dateModified" datetime="2020-08-10T01:25:23+08:00">2020-08-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="正负和原码之难"><a href="#正负和原码之难" class="headerlink" title="正负和原码之难"></a>正负和原码之难</h2><p>在计算机中区分正负数有许多好处，此时可以只考虑一个，不用特别设计和实现减法，将减法转换为加法即可：</p>
<script type="math/tex; mode=display">
5-3=5+(-3)</script><p>下表展示了3位数中的应用实例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">十进制表示</th>
<th style="text-align:center">原码</th>
<th style="text-align:center">补码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">000</td>
<td style="text-align:center">000</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">001</td>
<td style="text-align:center">001</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">010</td>
<td style="text-align:center">010</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">011</td>
<td style="text-align:center">011</td>
</tr>
<tr>
<td style="text-align:center">-4</td>
<td style="text-align:center">N/A<strong>*</strong></td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">-3</td>
<td style="text-align:center">111</td>
<td style="text-align:center">101</td>
</tr>
<tr>
<td style="text-align:center">-2</td>
<td style="text-align:center">110</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">-1</td>
<td style="text-align:center">101</td>
<td style="text-align:center">111</td>
</tr>
</tbody>
</table>
</div>
<p>就像为了标明数的正负而在开头添加＋或－一样，用二进制数的第一位表示正负和剩余位数表示值是理所当然的做法。原码第一位作为符号位，0表示负，1则表示正，剩余位数就是原数绝对值的二进制表示。</p>
<p>数被表示好了，并且能区分正负，接下来当然要进行运算，那么问题出现了：</p>
<script type="math/tex; mode=display">
3+(-3)=0\neq010=011+111</script><p>那么该将如何呢？让计算机去根据符号位进行判断大概是最直观的解决，这当然没错。然而需要注意的是，加法在计算机中已经是非常基础的运算，它理应尽可能地简单，否则将严重拖累计算机的性能，之前提到的把减法视作加法也基于这样的原则。带上新条件重新思考，那么摆在脚下的路仍然是让符号位也参与加法运算，所以原码这样的方法是行不通了。</p>
<h2 id="冯·诺依曼小剧场"><a href="#冯·诺依曼小剧场" class="headerlink" title="冯·诺依曼小剧场"></a>冯·诺依曼小剧场</h2><p>首先重新看回上面的原码运算，<strong>请特别注意在有限的3位数中011+111的结果并不是1010，计算机“丢弃”了超越的进位！进位而位不足便添位在人的认识中是非常自然的，但对于计算机并非如此。这个容易略过的事实十分重要。</strong></p>
<hr>
<p>现在请考虑：你是一个认得0~9的十进制思想的人，你只能做加法，你有且只有一位数，不得添也不得去，9+1的结果对于你来说是多少？暂时跳出这个奇怪的身份，当然会知道9+1=10，但此时的你并不能添位，因此10里的1就这么“溢出”了，你丢掉了这个数字，以仅剩下的0作为结果。在有限位数的计算中，一直持续加下去，并不会得到＋∞，而是在有限位数的有限表示中循环：0, 1, 2… 8, 9, 0, 1, 2…</p>
<p>请再考虑：虽然你只能做加法，却有人需要你做减法，现在轮到这位强人所难的家伙头疼了，他知道不能让你进行8-3这样的运算，既然只能做加法那就做加法，那么8加上什么数才可以呢。他也想起了上面提到的循环，于是他知道了，让你计算8+7的结果便能得到和8-3相同的结果。他决定做一张对照表，把某些类似+7和-3这样成对关联的数对应起来，方便查询。依样画葫芦，他得到了这样一张表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>他：</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>-5</th>
<th>-4</th>
<th>-3</th>
<th>-2</th>
<th>-1</th>
</tr>
</thead>
<tbody>
<tr>
<td>你：</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p>他进一步想到，万一你以后可以支持更多位和更多表示了呢，又重新来一遍不成？要找出这种映射的规律，细细一看，并不难发现：</p>
<p>  -5+10=5，-4+10=6，-3+10=7……</p>
<p>原来如此，原值和映射值之和等于10。为什么是10呢，他稍微对更高表示量的情况作了验证，确实这个和就是适逢进位溢出的那个数。</p>
<h2 id="补码，重整乾坤"><a href="#补码，重整乾坤" class="headerlink" title="补码，重整乾坤"></a>补码，重整乾坤</h2><p>补码，就是一种在计算机中用二进制数表示有正负符号的数的方法。用这种方法处理整数时，正数的补码为其原码，而负数的补码与原码之和为2<sup>N</sup>。 对于二进制数，N位数适逢进位溢出的数就是2<sup>N</sup>。</p>
<p>约翰·冯·诺依曼当然不会组织这样的小剧场，他倒确实是补码的提案者，而补码的用意就和小剧场里的映射表一样，要将一系列循环表示的前半部分当作正数，后半部分当作负数，这样便同时解决了表示正负，以加代减和令加法简单这整整三个问题。</p>
<p>你应该已经注意到在第一张表格中，-4只有对应的补码，而原码不适用。这样写当然是不对的。不经修正的原码有这样的缺陷：000和100在原码中严格地看来代表着＋0和－0，但±0对于数学和正常人来说都是没有意义的。为了满足0就是0，指定000就是0而不是什么＋0，那100又如何处置呢，不能指定它就是4，因为第一位数被用来表示正负而不是值，你会发现在原码方法有这样一个叫人万般尴尬的特殊情况——即使强行为负零指定了某个特定的值，也不会有什么额外好处。</p>
<p>万幸的是在补码中没有这么尴尬，就当100是-4的原码，则-4的补码也是100，所以补码还处理了正负零这第四个问题（如Java中占8位的byte型表示－128~127而不是－127~127，－128~－1和0~127都有128个数），当然在真正使用原码和反码的情况里也是能解决正负零问题的，只是不如补码自洽且利于计算。</p>
<p>看得出，原码是一种“天真简单的”映射，而补码旨在重排。你可以为它们找出很多联系来绕晕自己，甚至联系反码来进一步绕晕自己，或者把它们看成泾渭分明的三种方法——你完全不需要知道原码也可以使用补码，只需要遵照以下规则：</p>
<ol>
<li>使用总数为偶数的一系列循环二进制数。</li>
<li>将这些表示对半拆开。</li>
<li>前半部分依次表示0, 1, 2… N。</li>
<li>后半部分依次表示－(N+1), －(N), －(N-1)… -1。</li>
</ol>
<p>你也可以把-3+10=7理解成-3和7对10同模，并提炼出这样的关系：</p>
<script type="math/tex; mode=display">
j\equiv(j+k)\pmod{k}</script><p>毕竟：</p>
<script type="math/tex; mode=display">
j\mod{k}=j-k\quad (j\ge k>0)</script><p>表示方法和理解都是可以有很多种的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IlluminatedWorm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
