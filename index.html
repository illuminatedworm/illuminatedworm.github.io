<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="IlluminatedWorm&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IlluminatedWorm&#39;s Blog">
<meta property="article:author" content="IlluminatedWorm">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>IlluminatedWorm's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">IlluminatedWorm's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">IlluminatedWorm</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/illuminatedworm" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;illuminatedworm" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:609210163@qq.com" title="E-Mail → mailto:609210163@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/inline%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/inline%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/" class="post-title-link" itemprop="url">inline的二三事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 19:38:08" itemprop="dateCreated datePublished" datetime="2020-11-09T19:38:08+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-10 20:50:05" itemprop="dateModified" datetime="2020-11-10T20:50:05+08:00">2020-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文涉及关键词<code>inline</code>，<code>noinline</code>，<code>crossinline</code>，还会顺便提一下Lambda表达式里的返回值和<code>reified</code>。</p>
<p>对于内联，其中<code>noinline</code>和<code>crossinline</code>两个关键词，即使你不知就里，在IDE的提示下仍可以正确使用。</p>
<h2 id="为什么有inline"><a href="#为什么有inline" class="headerlink" title="为什么有inline"></a>为什么有inline</h2><p>Kotlin的一大特点是主张使用高阶函数配合函数类型建立高可用的自定义结构进行编程，这样有助于控制流程高抽象化和提高代码复用。所谓的高阶函数是指以函数为参数或者返回值的函数（这个概念来自数学，如果你把求导和积分也看作函数，那么你会发现它们的参数和结果都可能是另一个函数）。</p>
<p>然而和Java一样，Kotlin中的函数实际上也不能作为参数传递，被传递的东西<strong>最终本质</strong>上是一个对象（“函数类型”不是“函数”，<code>mehtod()</code>和<code>(::method)()</code>在底层发生了不同的事）。那么这便引申出一个问题，对象的创建是有代价的，这份代价虽然小，但也绝非没有，如果一个高阶函数被频繁调用——例如在一个执行很多次的循环体里被调用——会怎么样呢？</p>
<p>是的，这可能导致大量的对象被创建，造成显著的性能问题。Kotlin需要提供一种简单且显著的解决方法，所以<code>inline</code>便诞生了。</p>
<p>如果具有C++背景将非常容易理解什么是内联（inline），这个词的核心表示是<strong><em>替换</em></strong>，你向编译器<strong>推荐</strong>用被内联物的内容代替被内联物。Java中没有内联（可能的内联只会发生在运行时JVM的自主优化，这对程序员是完全透明的），Java中最接近的是编译器对编译时常量的优化：如果一个字面量类型变量的值在编译时已知。那么对它的引用将会被替换为值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_APPLICATION_NAME = <span class="string">"project-user"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">List&lt;InstanceInfo&gt; instances = discoveryClient.getInstances(USER_APPLICATION_NAME);</span><br></pre></td></tr></table></figure>
<p>像这样的代码，编译器便会把<code>getInstances()</code>方法的参数从对<code>USER_APPLICATION_NAME</code>的引用替换为<code>&quot;project-user&quot;</code>。</p>
<p>这就是内联，只不过在Kotlin中的，编译器做的更多，它为你把函数调用替换成了被调用函数里的代码，并且做了一些保证最终效果一致性的工作（顺便一提，在Kotlin中调用内联函数时传入<code>++i</code>和<code>i++</code>这种参数不会产生C++的经典Bug）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, <span class="variable">$s</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码在编译后大致是这样的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, Kotlin"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, Kotlin"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, Kotlin"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"Hello, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"I`m a inline function, <span class="variable">$s</span>"</span>)</span><br><span class="line">    println(<span class="string">"Goodbye, <span class="variable">$s</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是一个用于说明的简单例子，实际上如果真的这么做，IDE会提示你，这么做起不到优化作用，因此没有必要添加<code>inline</code>，它应该被用在函数参数有函数类型的情况下。这种提示的强烈暗示加上之前关于对象创建的代价问题（当然，你可以去看字节码来完全证实），已经可以摸到<code>inline</code>更主要的目的：把函数类型的参数也进行内联。没有什么参数传递了，也没有对象被创建了，直接跑原本的代码吧。</p>
<p>现在远非万事大吉，引入<code>inline</code>解决了一个问题，但又引发了另一些问题（喜闻乐见的环节）。即使在上面这个十分简单的说明用例里，你也可以发现代码变多了，内联函数会导致字节码膨胀，这不但会让最终打包的文件容量变大，还可能影响运行效率（毕竟，需要运行的代码变多了），违背<code>inline</code>被引入的初衷。所以IDE才会有那个提示，告知你只有高阶函数才适合内联化，其实这也并不足够，程序员应当小心掂量，只对频繁被调用的高阶函数进行内联化，但这劳累心智，某些情况下也不现实（如果你写的是类库，你怎么肯定使用者的用法？）。</p>
<h2 id="noinline？"><a href="#noinline？" class="headerlink" title="noinline？"></a>noinline？</h2><p>这个关键词字面意思看起来挺明白的，意思就是不要内联化，那怎么的又需要非内联化呢？</p>
<p>在上面已经说过，高阶函数能以函数作为返回值，而就像函数其实不能作为参数一样，函数其实也不能作为返回值，在Kotlin中返回函数也是返回了一个对象，这个函数类型的对象和函数并不是一个东西。</p>
<p>而编译器对内联化函数的函数类型的参数也执行了内联，现在没有什么函数类型了，只剩下最纯洁朴素的等价代码块，显然代码块不能被返回。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> aFunction = saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        println(<span class="string">"Hello, <span class="variable">$it</span>"</span>)</span><br><span class="line">        println(<span class="string">"I`m a inline function, <span class="variable">$it</span>"</span>)</span><br><span class="line">        println(<span class="string">"Goodbye, <span class="variable">$it</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span>: (String) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line">    f(s)</span><br><span class="line">    <span class="keyword">return</span> f <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDE直接就提示了：</p>
<blockquote>
<p>Illegal usage of inline-parameter ‘f’ in ‘public inline fun saySth(s: String, f: (String) -&gt; Unit): Unit defined in root package in file main.kt’. Add ‘noinline’ modifier to the parameter declaration</p>
</blockquote>
<p>只要给参数<code>f: (String) -&gt; Unit</code>加上<code>noinline</code>前缀，就可以成功编译并运行了。如果你真的这么做，你会发现IDE又提示<code>inline</code>不被建议了，因为这个说明用例里只有一个函数类型的参数。显然<code>noinline</code>的使用场景是：在至少有两个函数类型的参数的内联化高阶函数中，需要返回某一个函数类型的参数，就给它加上<code>noinline</code>。不用记着，IDE和编译器会让你正确的。</p>
<h2 id="Kotlin的Lambda好像不能写return？"><a href="#Kotlin的Lambda好像不能写return？" class="headerlink" title="Kotlin的Lambda好像不能写return？"></a>Kotlin的Lambda好像不能写return？</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getSaySth</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""" // 错误</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            Goodbye,<span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"no thing to said."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    f(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(getSaySth())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑这个代码，Lambda表达式中的<code>return</code>究竟返回到哪个函数？是<code>saySth()</code>还是<code>main()</code>，有点意味不明，而Kotlin选择不允许这么做（当然你可以使用带标签的<code>return@saySth</code>），你或许觉得同样的事情在Java中被允许而在Kotlin中重新规定有点可笑，但得记住，在Kotlin里Lambda表达式有更多玩法，例如在类型安全的构建器里出现<code>return</code>就明显不合适。在Kotlin中，Lambda表达式默认以最后一行代码为返回值。</p>
<p>但只要你见过的Kotlin代码够多，你或许见过能写<code>return</code>的Lambda表达式。是的，内联函数的函数类型参数就允许被写<code>return</code>，因为内联化破坏了被调用函数的作用域，联系第一小节的例子，你就能明白，Lambda表达式里的<code>return</code>已经很明白地指向<code>getSaySth()</code>了，对<code>saySth()</code>的调用已经消失了。</p>
<p>所以只要给<code>saySth()</code>加上<code>inline</code>修饰符，以上代码就能成功编译和运行，并输出“Hello……”的文本。</p>
<p>我认为这是Kotlin中过度设计的一点，虽然一切最终符合Kotlin的设计哲学（简单易用：你不需要知道一个高阶函数是否内联来判断是否可以在Lambda表达式中使用<code>return</code>，但只要能使用<code>return</code>你就知道这个函数是内联的），但内联化高阶函数的<code>return</code>被搞得如此复杂，在带标签的<code>return</code>存在的前提下，这真的有必要吗？</p>
<h2 id="crossinline又是怎么回事？"><a href="#crossinline又是怎么回事？" class="headerlink" title="crossinline又是怎么回事？"></a>crossinline又是怎么回事？</h2><p>记住关于Lambda表达式中<code>return</code>的问题，考虑以下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, f: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    withContext(Dispatchers.Default) &#123;</span><br><span class="line">        f(s) <span class="comment">// 错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> str = <span class="string">"""</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            Goodbye,<span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">        println(str)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么不能编译呢，IDE这样说：</p>
<blockquote>
<p>Can’t inline ‘f’ here: it may contain non-local returns. Add ‘crossinline’ modifier to parameter declaration ‘f’</p>
</blockquote>
<p>和<code>noinline</code>一样，你不需要搞明白为什么，依提示加上<code>crossinline</code>即可。但现在看提示再联系返回值的问题，你就会明白，对<code>f(s)</code>的调用并不是由<code>saySth()</code>发起的，甚至都不是在本线程被调用，它被交给了某个协程来调用。如果<code>f(s)</code>会返回，那返回到谁呢，显然上一小节提到的处理不适合这种情况，毕竟它都在别的协程里被调用了！并且你可以看到，在这个例子里<code>f</code>的返回值是<code>Unit</code>也不会例外。</p>
<p>所以就需要<code>crossinline</code>来允许和优化这种特别的调用（发现了吗，Kotlin能帮你完成不同线程间变量的安全传递，而至于我们，基本上什么也不用做）。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">saySth</span><span class="params">(s: <span class="type">String</span>, <span class="keyword">crossinline</span> f: (<span class="type">String</span>) -&gt; <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> withContext(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@withContext</span> f(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> str = saySth(<span class="string">"Kotlin"</span>) &#123;</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            Hello, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I`m a inline function, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">            I'm running in <span class="subst">$&#123;Thread.currentThread().name&#125;</span></span></span><br><span class="line"><span class="string">            Goodbye, <span class="variable">$it</span></span></span><br><span class="line"><span class="string">        """</span>.trimIndent()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"main is running in <span class="subst">$&#123;Thread.currentThread().name&#125;</span>"</span>)</span><br><span class="line">    println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果（想看见协程名需要加入JVM运行参数：-Dkotlinx.coroutines.debug）：</p>
<blockquote>
<p>main is running in main @coroutine#1<br>Hello, Kotlin<br>I`m a inline function, Kotlin<br>I’m running in DefaultDispatcher-worker-1 @coroutine#1<br>Goodbye, Kotlin</p>
</blockquote>
<h2 id="reified"><a href="#reified" class="headerlink" title="reified"></a>reified</h2><p>在Java中，一个运用反射和泛型获取实例的最简单方法大概是这的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你必须向当中传入一个<code>Class&lt;T&gt;</code>类型的对象。而在Kotlin中你可以这样做：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getInstance</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> T::<span class="class"><span class="keyword">class</span>.<span class="title">objectInstance</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin的泛型和Java一样进行了泛型擦除，<code>reified</code>这个关键词只能在内联函数中使用，这是一个很简单的语法糖，你不再需要自己传入那个<code>Class&lt;T&gt;</code>了，编译器代你做了类似的事情。现在可以对<code>T</code>使用Kotlin中的<code>is</code>和<code>as</code>，配合智能类型转换，还是多少能省一些事，并且在函数的使用者看来，效果更加，例如在Spring提供的Kotlin Bean DSL中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> beans = beans &#123;</span></span><br><span class="line">  bean&lt;UserHandler&gt;()</span><br><span class="line">  bean&lt;Routes&gt;()</span><br><span class="line">  bean&lt;WebHandler&gt;(<span class="string">"webHandler"</span>) &#123;</span><br><span class="line">    RouterFunctions.toWebHandler(</span><br><span class="line">      ref&lt;Routes&gt;().router(),</span><br><span class="line">      HandlerStrategies.builder().viewResolver(ref()).build()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bean&lt;UserHandler&gt;</code>意味着去查找<code>UserHandler</code>的构造器来创建Bean，而<code>ref&lt;Routes&gt;</code>相当于是<code>applicationContext.getBean(Routes::class.java)</code>。</p>
<p>奇怪的是用Kotlin写Spring Boot时，并不能自然地运用这种DSL来创建Bean。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Stream类实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-23 13:34:41" itemprop="dateCreated datePublished" datetime="2020-10-23T13:34:41+08:00">2020-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-29 14:02:58" itemprop="dateModified" datetime="2020-10-29T14:02:58+08:00">2020-10-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考资料：《Java核心技术 卷二》，JDK8 API doc</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先看看<code>Stream</code>最重要的一点，执行顺序。示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeekThePeekMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;ValuePair&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">1</span>, <span class="string">"one"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">2</span>, <span class="string">"two"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> ValuePair(<span class="number">3</span>, <span class="string">"three"</span>));</span><br><span class="line">        list.stream()</span><br><span class="line">                .peek(valuePair -&gt; System.out.println(valuePair.getCode()))</span><br><span class="line">                .peek(valuePair -&gt; System.out.println(valuePair.getName()))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// constructors, toString, setter and getter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>1<br>one<br>ValuePair{code=1, name=’one’}<br>2<br>two<br>ValuePair{code=2, name=’two’}<br>3<br>three<br>ValuePair{code=3, name=’three’}</p>
</blockquote>
<p>明显可以看出，stream并不是在每次操作时对包含的每个元素进行遍历，而是只进行了一次遍历，否则每次操作的结果会相邻。</p>
<p>也就是说，stream的操作等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list) &#123;</span><br><span class="line">    System.out.println(valuePair.getCode());</span><br><span class="line">    System.out.println(valuePair.getName());</span><br><span class="line">    System.out.println(valuePair);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair.getCode());</span><br><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair.getName());</span><br><span class="line"><span class="keyword">for</span> (ValuePair valuePair : list)</span><br><span class="line">    System.out.println(valuePair);</span><br></pre></td></tr></table></figure>
<p><code>Stream</code>和第一种for-each循环的效果符合人类思维的自然预想，剩下的那种显然不对。这里想表达的重点在于，<code>Stream</code>是如何将三个操作压缩到一起执行的呢？稍微想想就能发现，最简单直接的实现方式——转存数据结构，对每个操作方法以循环来实现——达成的效果是三个顺序执行的for-each循环那样的。</p>
<p>那么要达成预期效果，自然会想到一种方式：<strong>记录</strong>而非执行。将操作记录下来，最终统一执行。更本质地讲，就是将执行<strong>延迟</strong>，这就是为什么<code>Stream</code>类的方法接受的参数都是Lambda表达式（函数式接口），使用Lambda表达式的用意在某种程度上就是要让执行被推后。</p>
<p>我们完全可以想象（如果熟悉Java中Lambda表达式的实现方式的话，这里就不讲了invokedynamic，<code>MethodHanlder</code>，<code>CallSite</code>和内部类那些事儿了……），这些Lambda表达式都被记录在某个集合里，最终被拿出来遍历执行。</p>
<h2 id="对照例子"><a href="#对照例子" class="headerlink" title="对照例子"></a>对照例子</h2><p>另一个例子，作为后文的具象参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"cat"</span>);list.add(<span class="string">"dog"</span>);list.add(<span class="string">"pig"</span>);</span><br><span class="line">list.add(<span class="string">"olIve"</span>);list.add(<span class="string">"pinK"</span>);list.add(<span class="string">"silVer"</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.length() &gt; <span class="number">3</span>)</span><br><span class="line">    .map(s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + s.substring(<span class="number">1</span>).toLowerCase())</span><br><span class="line">    .sorted()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>过程追踪：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/trace.png" class="">
<p>输出结果：</p>
<blockquote>
<p>Olive<br>Pink<br>Silver</p>
</blockquote>
<h2 id="如何记录？"><a href="#如何记录？" class="headerlink" title="如何记录？"></a>如何记录？</h2><p>一张<code>Stream</code>实现的继承关系图：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/overview.png" class="">
<p>这当中没有画出对<code>int</code>，<code>long</code>和<code>double</code>特化的类，<strong>但它们存在</strong>。它们的结构也基本为Stream &lt;- Pipleline &lt;- Head+StatefulOp+StatelessOp。因为Java的泛型并不支持原始类型，而使用包装类带来的打包和解包有性能损耗，因此具有这些特化的类。</p>
<h3 id="头"><a href="#头" class="headerlink" title="头"></a>头</h3><p>对示例代码进行追踪，可以发现<code>list.stream()</code>的作用是：</p>
<ol>
<li>获取<code>ArrayList</code>的<code>Spliterator</code>对象（简单地说，就是可并行化的<code>Iterator</code>）。</li>
<li>将该对象传入<code>ReferencePipeline.Head</code>构造器创建出<code>Head</code>对象。<code>new ReferencePipeline.Head&lt;&gt;(spliterator, StreamOpFlag.fromCharacteristics(spliterator), parallel);</code></li>
</ol>
<p>看看这个构造器的签名：<code>Head(Spliterator&lt;?&gt; source, int sourceFlags, boolean parallel)</code>。很简单易懂，<code>Spliterator</code>即数据源，parallel表示是否并行化，在这里为<code>false</code>，sourceFlags是由前文方法以数据源算得的特征值，从<code>StreamOpFlag</code>类的注释中可以知道，这是一个表示多项状态的<code>int</code>值（掩码）：</p>
<ul>
<li>DISTINCT 是否独特 （例如，<code>Set</code>是独特的，而<code>List</code>不是）</li>
<li>SORTED 是否排序（例如，<code>SortedSet</code>是排序的，而<code>ArrayList</code>不是）</li>
<li>ORDERED 是否有序（例如，<code>ArrayList</code>是有序的，而<code>HashMap</code>不是）</li>
<li>SIZED 已知或未知大小（<code>Stream</code>支持无限流）</li>
</ul>
<p>我们并不关心特征码的具体情况，我们只需要知道，<code>Stream</code>记录了这些信息，留待后用。</p>
<p>最终<code>Head</code>对象的实际创建落到<code>AbstractPipeline</code>的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AbstractPipeline(Spliterator&lt;?&gt; source,</span><br><span class="line">                 <span class="keyword">int</span> sourceFlags, <span class="keyword">boolean</span> parallel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.previousStage = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.sourceSpliterator = source;</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = sourceFlags &amp; StreamOpFlag.STREAM_MASK;</span><br><span class="line">    <span class="comment">// The following is an optimization of:</span></span><br><span class="line">    <span class="comment">// StreamOpFlag.combineOpFlags(sourceOrOpFlags, StreamOpFlag.INITIAL_OPS_VALUE);</span></span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = (~(sourceOrOpFlags &lt;&lt; <span class="number">1</span>)) &amp; StreamOpFlag.INITIAL_OPS_VALUE;</span><br><span class="line">    <span class="keyword">this</span>.depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.parallel = parallel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个典型的链表单元，包含着相关信息，并且是头——指向的前单元为<code>null</code>。</p>
<h3 id="身"><a href="#身" class="headerlink" title="身"></a>身</h3><p>追踪<code>filter()</code>方法，发现与头的处理类似，实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                 StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两层重写建立了一个具有定制的<code>opWrapSink()</code>方法的<code>StatelessOp</code>对象，该方法能返回一个定制的<code>Sink.ChainedReference</code>对象。<code>Sink</code>是扩展的<code>Cosumer</code>接口：</p>
<img src="/2020/10/23/Stream%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/sink_overview.png" class="">
<p>这些方法的目的大致如下：</p>
<ul>
<li><code>begin()</code>，最先触发，重置<code>Sink</code>状态以接受新数据。与流大小变化有关，这上面的例子中，传入参数-1表示后续流大小未知或无限。</li>
<li><code>accept()</code>，当前处理步骤。</li>
<li><code>cancellationRequested()</code>，表示该步骤不再接受任何数据。与短路/非短路操作有关。</li>
<li><code>end()</code>，最后触发，已接受完所有数据。与有状态/无状态操作有关。</li>
</ul>
<p>创建<code>StatelessOp</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更加清晰了，能看出代码在制造双向链表。</p>
<p><code>StatefulOp</code>的相关代码更加复杂，就不展示出来撑爆这篇博客的长度了，总体思路和<code>statelessOp</code>是相同的，最大的区别是<code>StatefulOp</code>中的<code>end()</code>方法经过了复杂的重写，因为有状态的操作依赖上一次操作的结果，所以需要在<code>end()</code>中执行处理。</p>
<h3 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h3><p>结束方法并没有与之前的链表链接，而是从链表尾遍历到头，完成翻转的打包，再进行执行，对于<code>forEach()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>) AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用<code>forEach()</code>方法举例的原因就是相比其他结束方法相对简单……</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然<code>Stream</code>的使用非常直观简单，但其具体实现可以说很是令人头晕目眩，即使抛掉流那些用于检验判断的元信息和其传递过程来看，也得在繁多的多态关系间检索。</p>
<p>不得不承认针对面向对象编程抽象过度的批评是有道理的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/" class="post-title-link" itemprop="url">HashMap容量背后的争论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-11 19:34:06" itemprop="dateCreated datePublished" datetime="2020-10-11T19:34:06+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-25 15:22:43" itemprop="dateModified" datetime="2020-10-25T15:22:43+08:00">2020-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="HashMap的奇怪容量设置"><a href="#HashMap的奇怪容量设置" class="headerlink" title="HashMap的奇怪容量设置"></a>HashMap的奇怪容量设置</h2><p>在JDK的<code>HashMap</code>中，它的默认初始容量为16，用户输入的任何初始容量都会被计算为不小于输入的2的整数次幂，在实例发生扩容时也会保持容量为2的整数次幂。</p>
<p>这是一个比较奇怪的事实。经典书籍《算法导论》中关于散列表的章节是这么说的：</p>
<img src="/2020/10/11/HashMap%E5%AE%B9%E9%87%8F%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%89%E8%AE%BA/1.png" class="">
<p>《算法导论》认为，当采用除法散列法时，散列表的大小应该选取一个较大的，不接近2的整数次幂的质数，并且应该避免选择2的整数次幂。这个说法符合直觉，并且应该是对的，有许多衍生的分析，比如具体哪些数比较好（碰撞率低而本身又不是非常大）。</p>
<p>但JDK采用的实现，完全与之相悖，虽然官方并没有作出具体解释，但在<a href="https://docs.oracle.com/javase/tutorial/collections/implementations/set.html" target="_blank" rel="noopener">这个网页</a>里提到：</p>
<blockquote>
<p>In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. </p>
<p>（过去，选择质数作为初始容量有一些优势。现在不再如此。）</p>
</blockquote>
<h2 id="怎么回事？"><a href="#怎么回事？" class="headerlink" title="怎么回事？"></a>怎么回事？</h2><p>首先，矛盾存在的前提是，<code>HashMap</code>的散列方法也为除法散列法，然而查看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键在于<code>(tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null</code>，其实看JDK 7的代码更加简单明白（因为JDK 8中<code>HashMap</code>获得了一些改进，主要是树化机制）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以JDK的散列方法是<code>h &amp; (length-1)</code>这样一个怪异的位运算，而不是取模。似乎这就是答案了：散列方法不同，没有什么矛盾。位运算更快，所以JDK的做法也可取。</p>
<p>网上不少分析看起来都是按照这个思路发生的，既然是新方法，那么就找出一些合理性，直接进入喜闻乐见的二进制环节，还能顺便把<code>hash()</code>方法为什么要对哈希值作位运算再与原值作异或运算讲了。</p>
<p>但很多分析都忽略了一个更直接的事实：<strong><em>当length为2的整数次幂时，hash &amp; (length - 1) = hash % length</em></strong>。并且因此<strong>混淆了<code>hash()</code>方法和散列方法的意图</strong>。即便这种做法作为一种tricky/hack的位运算技巧流传较广，但我才疏学浅不能解释背后的数学原理。</p>
<p>总之，JDK采用的散列方法本质仍然是除法散列法，而JDK做出的优化是用特定条件下的等价位运算来提升计算速度，<strong>这个优化并没有回避掉如此容量值产生的高碰撞率问题</strong>。根据<a href="http://blog.teamleadnet.com/2012/07/faster-division-and-modulo-operation.html" target="_blank" rel="noopener">这个博客</a>的说法，此优化提升巨大，高达10-20倍！我相信正是这样数量级的差异令JDK开发者做出了取舍。</p>
<p>那么JDK开发者又是怎么改善碰撞率的呢？这个的答案才在<code>hash()</code>方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，这里就不像其他分析一样写二进制示例了。hash ^ ( h &gt;&gt;&gt; 16)这个运算的目的用人话来说就是，<strong>将高位“融合进”低位，降低碰撞率</strong>，这包括俩方面：</p>
<ul>
<li>避免散列表容量较小的情况下（16位及以内，0 ~ 65535，显然，这是最常见的情况），运算时对散列值高位不敏感。</li>
<li>提高散列值低位分布方式的均匀程度。</li>
</ul>
<p>以上过程看待数字的角度在十进制和二进制之间切换而没有说明，因为这样写非常冗杂，但应该意识到这一点。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结一下：</p>
<ul>
<li><code>HashMap</code>取桶索引的算法大幅优化了运算速度，本质仍然是除法散列法，没有改善高碰撞率。</li>
<li>改善高碰撞率的是<code>hash()</code>方法，它将原散列值的高位“融合进”低位。</li>
</ul>
<p>所以，《算法导论》仍然是对的，直觉没有被违背。JDK的做法是基于原理论的取舍优化而不是全面舍弃——既保留位运算相对除法的巨大性能提升，又试图解决高碰撞率的问题。</p>
<p>计算机科学和数学关系莫大，却经常会在实践中超出数学的范畴，JDK的<code>HashMap</code>实现是一个例子，毕竟只从数学角度考虑，位运算和除法并没有什么区别，也不会有什么后续可言。类似的事情还在Dual-Pivot Quicksort这个经典排序算法里发生过，这个算法获得性能提升的关键在于计算机硬件而不是数学的算法分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/" class="post-title-link" itemprop="url">异步与同步，阻塞与非阻塞，并发与并行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-01 22:04:05" itemprop="dateCreated datePublished" datetime="2020-10-01T22:04:05+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-11 21:35:07" itemprop="dateModified" datetime="2020-11-11T21:35:07+08:00">2020-11-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Kotlin协程实现细节：<a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#implementation-details" target="_blank" rel="noopener">见此</a></p>
<p>Dragonwell的Wisp2：<a href="https://github.com/alibaba/dragonwell8/wiki/Wisp%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">见此</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在读《Java并发编程实战》，稍微整理一下基础知识。<br>这些术语是上下文相关的，也就是说具体取决于讨论范围和语境。这里只从Java并发编程的角度展开。</p>
<p>在Java中，线程生命周期如下：</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/Thread.png" class="">
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>相比标题里的前两者，并发和并行的区别更明显也更简单，所以第一个说。</p>
<p>借用名著《并发的艺术》的说法：</p>
<blockquote>
<p><em>A system is said to be</em> <em>concurrent</em> <em>if it can support two or more actions</em> <em>in progress</em> <em>at the same time. A system is said to be</em> <em>parallel</em> if it can support two or more actions executing simultaneously.</p>
<p>（如果某个系统支持两个或者多个动作同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。）</p>
</blockquote>
<p>区别在于“存在”和“执行”。</p>
<p>并发是指有多个线程都已经调用了<code>start()</code>，无论是在Java还是在其他领域，并发总是自然地被确保的，即使是在单核处理器的计算机上运行，多个线程也会交替地出入内存，也就是说，重点在于这些线程是同时存在的，仅此而已。</p>
<p>并行一定是指运行在多核处理器的计算机上的情况，多个线程被分配到不同的处理器内核上，真正的同时运行。</p>
<p>可以得出一些强化认识的推论：</p>
<ul>
<li>并行是并发的真子集（但在通常的语境下，并发所指的是不包含并行的那部分，应该意识到这一点。）。</li>
<li>对于单线程，这两个概念没有意义（Java程序肯定是多线程的——至少包括一个主线程和一个GC线程）。</li>
<li>在单核处理器的计算机上运行多线程程序一定是并发的。</li>
</ul>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>简单地说，阻塞与非阻塞就是关注线程是否会因某次操作而被挂起（等待，睡眠），而因为这几乎总是关乎系统调用，所以这对概念几乎总是与I/O一起被提及。之前已经说了本文只关注Java并发编程，不会讨论内核和底层的相关概念。</p>
<p>在<code>InputStream.read()</code>方法的文档中有这样的描述：</p>
<blockquote>
<p>Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes actually read is returned as an integer. This method blocks until input data is available, end of file is detected, or an exception is thrown.<br>If the length of b is zero, then no bytes are read and 0 is returned; otherwise, there is an attempt to read at least one byte. If no byte is available because the stream is at the end of the file, the value -1 is returned; otherwise, at least one byte is read and stored into b. </p>
<p>从输入流中读入一些字节并将其存入缓冲数组b，实际读取的字节数将以整数形式返回。此方法将阻塞，直到输入数据可用，检测到文件末尾或某个异常被抛出。</p>
<p>如果b的长度为零，则没有字节（会）被读取，返回0；否则，试图读取至少一个字节。如果因流达到文件末尾导致无字节可用，返回值-1；否则，至少有一字节被读取并存入b。</p>
</blockquote>
<p>虽然非常不像是人话，但这已经说尽了阻塞：当发起<code>read()</code>方法调用，直到达成某些条件前，将没有可用的结果，不管这些条件是预料的正常读取还是别的情况。既然没有可用的结果，那么当前线程运行下去将是意味不明的，将其挂起是完全理所当然的做法。</p>
<p>而非阻塞是指，调用不会使得线程挂起，在定义上就是这么简单。</p>
<h2 id="异步与同步"><a href="#异步与同步" class="headerlink" title="异步与同步"></a>异步与同步</h2><p>再次声明，本文不会像许多同类讨论一样大谈内核和底层。在本文的讨论范围中，同步和阻塞完全是一回事，异步和非阻塞也是一回事。</p>
<p>但这样也导致本小节不会有什么真正可供鉴别的主题——<strong><em>抛掉硬件底层和操作系统层面的事情，所谓的异步与同步的差异，只是类库与框架呈现给程序员的表象</em></strong>。异步就是分离值的计算和获取，仅此而已。</p>
<p>本小节<strong>将通过JavaScript看异步编程</strong>，在Web编程中，因为AJAX的流行，从JavaScript中接触异步编程十分普遍。而Java的异步编程更多地见于JavaFX，Swing和数据分析等地方，相对地不是那么常见和便于举例。</p>
<p>许多Java程序员轻视JavaScript，以至于对<code>promise</code>对象所知甚少，但人人都见过这种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func(f)</span><br><span class="line">.then(f1)</span><br><span class="line">.catch(e1)</span><br><span class="line">.then(f2)</span><br><span class="line">.catch(e2)</span><br></pre></td></tr></table></figure>
<p>它的抽象概念是，调用某个函数，如果它有成功的结果，调用f1，否则是失败的结果，调用e1，f1和e1又可能有成功和失败的结果，类似地，根据情况分别再调用f2和e2。</p>
<p>但运行在某个浏览器中的JavaScript的代码总是阻塞的，JavaScript中根本没有线程概念，但它实际就是单线程的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码永远依次输出1，2，3，4。“主线程”在输出3之后，才去执行了<code>setTimeout</code>函数（实际上，JDK中的<code>Timer</code>类也是这样的，真正的多线程定时任务需要<code>ScheduledThreadPoolExecutor</code>，原生定时任务的实现别再用<code>Timer</code>了）。</p>
<p>所以这种情况下这<strong><em>真的异步</em></strong>了吗？阻塞和非阻塞这对概念尚且关注的是一个对象的状态，但异步和同步关注的一定是至少两个对象间的关系，所以，不是，它要解决的是程序员心智层面的认知问题，而不是CPU或者操作系统的问题。</p>
<p>JavaScript的实践中，经常会出现这种情况：这个函数需要那个函数的回调，另一个函数又需要这个函数的回调，甚至那个函数又依赖第四个函数的回调……在<code>promise</code>成为JavaScript官方规范和出现在第三方类库中之前，名为回调地狱的现象困扰着前端程序员，以下是一个夸张而搞笑的示例：</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/callback_hell.jpeg" class="">
<p>这样的代码看起来令人眼疼头疼，难以维护。现在的JavaScript，可以把这样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">nextStep</span> =&gt;</span> &#123;</span><br><span class="line">  getBeef(<span class="function"><span class="keyword">function</span> (<span class="params">beef</span>) </span>&#123;</span><br><span class="line">    cookBeef(beef, <span class="function"><span class="keyword">function</span> (<span class="params">cookedBeef</span>) </span>&#123;</span><br><span class="line">      getBuns(<span class="function"><span class="keyword">function</span> (<span class="params">buns</span>) </span>&#123;</span><br><span class="line">        putBeefBetweenBuns(buns, beef, <span class="function"><span class="keyword">function</span>(<span class="params">burger</span>) </span>&#123;</span><br><span class="line">          nextStep(burger)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">makeBurger(<span class="function"><span class="keyword">function</span> (<span class="params">burger</span>) =&gt; </span>&#123;</span><br><span class="line">  serve(burger)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>变成这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(<span class="function"><span class="params">beef</span> =&gt;</span> cookBeef(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">cookedBeef</span> =&gt;</span> getBuns(beef))</span><br><span class="line">    .then(<span class="function"><span class="params">bunsAndBeef</span> =&gt;</span> putBeefBetweenBuns(bunsAndBeef));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(<span class="function"><span class="params">burger</span> =&gt;</span> serve(burger));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用单参数函数的优势省略箭头函数的形式:</span></span><br><span class="line"><span class="keyword">const</span> makeBurger = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getBeef()</span><br><span class="line">    .then(cookBeef)</span><br><span class="line">    .then(getBuns)</span><br><span class="line">    .then(putBeefBetweenBuns);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>甚至是这样的（ES6的generator也可以做到，在此不举例）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> makeBurger = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> beef = <span class="keyword">await</span> getBeef();</span><br><span class="line">  <span class="keyword">const</span> cookedBeef = <span class="keyword">await</span> cookBeef(beef);</span><br><span class="line">  <span class="keyword">const</span> buns = <span class="keyword">await</span> getBuns();</span><br><span class="line">  <span class="keyword">const</span> burger = <span class="keyword">await</span> putBeefBetweenBuns(cookedBeef, buns);</span><br><span class="line">  <span class="keyword">return</span> burger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">makeBurger().then(serve);</span><br></pre></td></tr></table></figure>
<p>虽然每一行代码对应的具体<code>promise</code>对象的实现还是要落到程序员自己头上（所以还是那句话，没有什么魔法），但最终呈现的效果确实更清晰易读了，把有问题的实现方式换了一种实现方式（麻烦程度究竟有没有降低很难说，前端程序员中也有其他声音）。</p>
<p>JDK中也有着<code>promise</code>的等价物，即<code>CompletableFuture&lt;T&gt;</code>类（当然，还是<code>Future&lt;T&gt;</code>用得更多），最本质的不同还是在于多线程，此类下的某些方法允许程序员将任务交给其他线程执行。另外，<code>Collection</code>接口和<code>BaseStream</code>接口中分别提供了<code>parallelStream()</code>和<code>parallel()</code>方法，可以很方便地把原本的数据源并行化（这个说法是由方法名而来的，其实参考第一小节的结论，说是并发化更严谨），最终效果类似<code>async</code>和<code>await</code>关键词：写的是同步代码，执行却不是。而达成这种效果似乎是目前异步编程的主要趋势。</p>
<h3 id="协程，纤程，Project-Loom"><a href="#协程，纤程，Project-Loom" class="headerlink" title="协程，纤程，Project Loom"></a>协程，纤程，Project Loom</h3><p>协程/纤程（coroutine/fiber），同样的，这两个东西都是较基础的概念，具体实现有多种。</p>
<p>就JVM语言来说，Kotlin中已经有了协程，然而Kotlin/JVM中的实现方式可能有待时间考验，Kotlin用有限状态机控制的线程池实现协程（可以理解为Kotlin对Java并发做了一层十分友好的封装），这种实现方式下并不存在运行时协程。并且因为Project Loom的存在，可以预见，Kotlin协程在Android有着必要而稳固的地位，而在JVM上就显得有些前途未卜。</p>
<p>Loom是一个正在进行的纤程（协程Coroutine和纤程Fiber在本文讨论的语境中基本同义）类库，试图在JVM层面建立<strong>轻量级虚拟线程</strong>，以解决Java线程过于沉重而不够灵便的问题——与内核线程一比一相关，联系太紧密。</p>
<img src="/2020/10/01/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/fiber.png" class="">
<p>说白了，类似Go那样的做法（仍有区别，Loom是有栈协程，Goroutine是无栈协程，可以初步地认为前者有功能和兼容性的优势，而后者有性能优势），让“语言”来执行调度，自己的事情自己做，只不过Loom似乎还打算支持yield点（Python中<code>generator</code>那样的东西，注意这个是无栈协程）。一切听起来都很美好，除了这个项目还未落地，在此之前，Kotlin可能是JVM平台异步编程的优选。</p>
<p>又或者，可以考虑阿里巴巴的Dragonwell？这个OpenJDK分支的Wisp2功能允许以一个JVM参数开启此功能，将几乎整个<code>Thread</code> API无缝转换成协程实现，在一个简单的实例中获得了数量级的性能提升。同时，绝大多数相关功能都被支持（包括整个JUC包），当然存在少数局限和注意事项。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说到这一步，我们会发现，如果不按具体层次讨论，标题中的三对概念就会变得格外混乱，根本无从议起。</p>
<p>难道JavaScript的异步编程只是个肤浅的称呼吗？它切实地解决了一些心智负担问题。</p>
<p>难道并行流就不能在单核处理器的计算机上运行吗？当然可以。</p>
<p>程序员能确保并行代码一定在真正并行吗？这似乎主要是JVM，操作系统和硬件的事情，程序员仅仅提供了并行代码。</p>
<p>这些术语的使用有严格的界定吗？看看并行流和异步编程。</p>
<p>异步一定比同步好吗？非阻塞一定比阻塞好吗？并行一定比并发好吗？多线程一定比单线程好吗？这些问题只有一个确定而非常无聊的答案，根据实际情况而定。</p>
<p>没有什么魔法，不会因为几个概念的提出和辨明就能解决复杂的问题，问题永远会在那里，甚至不止一个。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/26/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%E4%B8%8Ecome-from/" class="post-title-link" itemprop="url">面向切面编程与come from</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-26 23:07:42" itemprop="dateCreated datePublished" datetime="2020-09-26T23:07:42+08:00">2020-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-11 17:05:11" itemprop="dateModified" datetime="2020-10-11T17:05:11+08:00">2020-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>太阳底下没有新鲜事。</p>
<h2 id="goto与其批评"><a href="#goto与其批评" class="headerlink" title="goto与其批评"></a>goto与其批评</h2><p> goto在Java中是保留关键字而不可用（虽然在字节码里我们可以找到它），唯一接近的东西是带标签的<code>break</code>语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) <span class="keyword">break</span> label;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这已经是它最常见的用法，跳出嵌套的控制语句，普通的<code>break</code>只能跳出当前循环。我相信多数人都对它很陌生，也许只有在极少的专注算法实现的代码里会用得上带标签的<code>break</code>语句。</p>
<p>许多编程语言都像java一样彻底不支持<code>goto</code>，或者十分有限地支持<code>goto</code>，当然也有不少语言（包括所谓新时代的语言）是完全支持的。<code>goto</code>被众多编程语言舍弃不是毫无理由的，数十年间，对<code>goto</code>的批评就没有停歇过，许多人认为，<code>goto</code>会造成混乱，它提供了一种强大的能力：让你随意跳转到当前作用域内任意处（这里说的是最原生态的那种<code>goto</code>）。确实容易想象这样的情景：你在查看既有代码，读到某一行时，忽然发现了<code>goto</code>，于是你跳转到它指向的位置，继续读下去却发现了另一个<code>goto</code>……最终，你得在脑海里梳理出一个便于理解的结构。</p>
<p>语法被滥用固然不全是语法本身的错，但像<code>goto</code>这样的语句格外容易被滥用，它太简单，效果却太强。<code>goto</code>代表的逻辑不是很符合人类的思维，“当怎样，就去哪里做什么云云”这样的思维活动大概只会在你看那些最不近人情的使用说明书时发生。</p>
<p>无论如何，这不会是一场有答案的争论，就像其他一切关于编程语言的哲学与风格的争论。</p>
<h2 id="comefrom，一个笑话"><a href="#comefrom，一个笑话" class="headerlink" title="comefrom，一个笑话"></a>comefrom，一个笑话</h2><p>如果你也认为<code>goto</code>确实比较糟糕，那你可能想不到它竟然能更糟，只需要把<code>goto</code>反转过来：运行到那处，跳转到此处。更糟的事情发生了，对于<code>goto</code>，你至少是明确地读到了它，清晰地意识到了这个跳转，但对于<code>comefrom</code>呢，你恐怕需要认真地看遍所有的代码，把它们都同时装在脑子里，才能进行结构梳理。</p>
<p>不用担心，<code>comefrom</code>从来都是一个笑话，没有任何高级编程语言严肃地考虑过实现它，曾经有人在愚人节发布了python的<code>goto</code>和<code>comefrom</code>实现，虽然确实可用，但它仍然不是认真的。</p>
<h2 id="AOP……？"><a href="#AOP……？" class="headerlink" title="AOP……？"></a>AOP……？</h2><p>现在从编程史话回到现实，重新考虑一下AOP，SpringAOP，每个Java程序员在最初接触到它时，都被灌输了一大堆概念：它是什么什么，它怎么怎么好，它不是OOP的代替而是补充……当尘埃落定，学会怎么用它之后，会发现也不过如此，我们用AOP做什么？日志记录，数据统计，统一异常处理，事务化。确实，如同最初得到的承诺，我们用AOP来做非核心业务的事情，并且效果斐然——毕竟把日志记录语句到处插入既杂乱又费事。</p>
<p>但是，这从来都不是AOP的全部。SpringAOP只用到了AspectJ的部分功能，SpringAOP仅仅允许用户切入方法（SpringAOP的within，this和target选择器功能并不完整），当用户试图使用AspectJ的其他切入点，程序会抛出<code>IllegalStateException</code>异常。而完整的AspectJ其实允许用户切入成员变量，构造器和控制流代码块。这部分是因为，SpringAOP的实现方式是动态代理（JDK原生和CGLib），而AspectJ的主要做法则是在编译时改造原有字节码（在这种实现里，相关行为被称为织入weave才更贴切，核心代码就像一件毛衣，而AspectJ把切面代码编织插入核心代码，就像在毛衣上点缀装饰），显然后者需要自己的编译器，实际上，AspectJ有着自己的语法和对应的一整套开发环境。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个Demo切入了Foo类的某个字段和所有构造器。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">privileged</span> <span class="class"><span class="keyword">aspect</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt0</span>() : <span class="keyword">get</span>(* com.illuminatedworm.test.Foo.localDate);</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">pt1</span>() : <span class="keyword">initialization</span>(com.illuminatedworm.test.Foo.<span class="keyword">new</span>(..));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">before</span>() : pt0() || pt1() &#123;</span><br><span class="line">        System.out.println(<span class="string">"----Advice triggered----"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">thisJoinPoint</span>.toString());</span><br><span class="line">        System.out.println(<span class="string">"target: "</span> + <span class="keyword">thisJoinPoint</span>.getTarget());</span><br><span class="line">        System.out.println(<span class="string">"this: "</span> + <span class="keyword">thisJoinPoint</span>.getThis());</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们当然可以只用AOP来方便日志记录业务，<strong><em>但AOP从来没有保证过自己只能做这样的事情</em></strong>，我们完全能修改方法的实参，甚至直接返回另一个不相干的结果。只是通常没人这么做罢了。</p>
<p>AOP难道不会令人想起<code>goto</code>和<code>comefrom</code>么？恕我大胆地说，AOP完全就是<code>comefrom</code>和<code>goto</code>的高级形式，而且更过分，切面与核心代码间的耦合度更低，像AspectJ这样的实现还帮你把相关上下文打包传递过来了（从这一点看，AOP是OOP的补充这种说法十分令人信服），只要愿意，程序员可以做许多事情。如果你认为这只是臆想，那么你真的该看看Aspectj的文档，编译时织入只是最简单的方式，只要用户愿意，编译后和加载时也可以进行织入，还有至今没有实现的运行时织入。</p>
<p>还记得我们假设的阅读带有<code>goto</code>和<code>comefrom</code>的代码是什么样的吗，阅读带有AOP的代码很难说会好到哪里去，把切面集中放到一个叫aspect的包里肯定很有帮助，但在庞大的工程里，模块和包数量众多。更荒唐的是，从察觉AOP的难易度来看，阅读被AspectJ编译器改造过的反编译代码远比阅读源代码容易察觉痕迹。</p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDate <span class="title">getLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> JoinPoint.StaticPart ajc$tjp_2;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">    <span class="keyword">protected</span> LocalDate localDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> ajc$preClinit() &#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory(<span class="string">"Foo.java"</span>, Foo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        ajc$tjp_0 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">18</span>);</span><br><span class="line">        ajc$tjp_1 = factory.makeSJP(JoinPoint.FIELD_GET, (Signature) factory.makeFieldSig(<span class="string">"4"</span>, <span class="string">"localDate"</span>, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>), <span class="number">30</span>);</span><br><span class="line">        ajc$tjp_2 = factory.makeSJP(JoinPoint.INITIALIZATION, (Signature) factory.makeConstructorSig(World.xsetITD_VERSION_ORIGINAL, <span class="string">"com.illuminatedworm.test.Foo"</span>, <span class="string">"java.time.LocalDate"</span>, <span class="string">"localDate"</span>, <span class="string">""</span>), <span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要因此认为AspectJ的实现方式比较糟糕，较真的话，这种实现方式性能更好，多创建几个对象和多运行几行代码的代价预期比SpringAOP的实现过程小。</p>
<h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>这里并没有贬低或者称赞任何东西。AOP，<code>goto</code>和<code>comeform</code>，它们如此地相似，“待遇”却截然不同，是AOP概念包装与实践门槛以及约定用法遏制了潜在的滥用吗？很难说得清，但我们可以发现，像是“只要怎样做就能如何好”这样的宣称几乎没有任何启示和指导作用，真正的价值仍然在于落到实处和如何落到实处。就像不要以AOP干预核心代码（事务化难道没有踩在这条红线上？我个人不是非常理解这怎么就不“核心”了），大家都明白，不过在其他时候，现成答案就不一定有了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">重新梳理泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 12:29:21" itemprop="dateCreated datePublished" datetime="2020-09-17T12:29:21+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-25 15:20:33" itemprop="dateModified" datetime="2020-10-25T15:20:33+08:00">2020-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>主要参考：《Java核心技术 卷一》，《Effective Java》，Oracle官方文档。</p>
<p>本文中的“泛型”一词没有特别说明，皆指Java的泛型。</p>
<h2 id="0-对于应用程序员，究竟应该了解泛型到什么程度"><a href="#0-对于应用程序员，究竟应该了解泛型到什么程度" class="headerlink" title="0 对于应用程序员，究竟应该了解泛型到什么程度"></a>0 对于应用程序员，究竟应该了解泛型到什么程度</h2><p>《Java核心技术 卷一》提到了这个问题，作者把对泛型的了解分为三个档次。我基本同意这种看法，不过我在实践中感到这一套说法应该有所补充。原文大意：</p>
<blockquote>
<ul>
<li><p>第一个档次，对于大多数程序员，知道它存在并且能用上就行了，了解具体机制是不必要的。</p>
</li>
<li><p>第二个档次，了解泛型，当泛型的使用出现问题时，能够自己做到系统性的解决。</p>
</li>
<li><p>第三个档次，能自己编写参数化类型和泛型方法。</p>
</li>
</ul>
</blockquote>
<p>听起来很美好，好像可以为自己定下某个预期水平，根据所需降低学习成本。但至少对于我个人而言，事实并非如此。</p>
<p>第一个档次根本是个幻景，只知道在IDE的提示下往尖括号内填写东西，并对此有所经验，毫不夸张地说，就是对泛型一无所知。</p>
<p>第二个档次和第三个档次实际上是分不开的，了解泛型最好方法（我甚至相信是唯一可行的方法）就是自己编写参数化类型和泛型方法。起初，我抱着一种达到介于第一档次和第二档次之间的心态，但我很快发现了至少两点非常现实的问题：</p>
<ol>
<li>使用泛型时偶尔会出错，并且感到一头雾水。“为什么不能这么做”？</li>
<li>在学习<code>Stream</code>的用法时，看不懂<code>Comparator</code>等接口的API，其中有着像是<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>这样的方法，看起来有些惊人。</li>
</ol>
<p>第二点是更广泛实践的一部分，只要你对函数式编程，Lambda表达式，流有一丝兴趣，我相信你也遇到过类似的问题。</p>
<p>我为此仔细学习了泛型的通配符规则，在此期间产生了一篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>，那之后，我感觉我“比较彻底地解决问题了”，对泛型已经有了足够的了解。但是当我学习Sedgewick的《算法》，试着自己实现一些数据结构时，却感到涉及泛型时仍然“举步维艰”。</p>
<p>我最终意识到，我需要重新系统地梳理泛型。</p>
<p>其实这个话题可以推而广之，“对于应用程序员，究竟应该了解某某到什么程度”。有些东西的确是不需要深入的，例如类型推断，官方文档中用了一整章来讲Java的类型推断，当中大量地使用了数学语言，可以说很是晦涩难懂，但类型推断在几乎所有情况下都可以正常运作且效果符合直觉，网上可见的大多数所谓类型推断失败都源于错误使用，正当使用中要无意地使类型推断失效几乎不可能，并且从高抽象层面上理解它也非常便利，因此我认为大可接受类型推断的原理是黑箱。</p>
<h2 id="1-为什么要有泛型"><a href="#1-为什么要有泛型" class="headerlink" title="1 为什么要有泛型"></a>1 为什么要有泛型</h2><p>在Java中，强制类型转换是一件令人痛苦的事情，编译器站在严格的角度，不能确保任何强制类型转换是安全的，程序员得自己认真考虑所有可能情况。但强制类型转换又是必要的，最典型的是像<code>Collection</code>接口下众多的实现类，他们被用来存储其他对象，显然针对被存储对象的不同类型针对编写各种实现是不现实的，那么在以前采取的做法是，向上转型，转到Java的终极超类<code>Object</code>，用<code>Object</code>来囊括一切，如<code>ArrayList</code>就持有一个<code>Object[]</code>。</p>
<p>但这种做法导致了令人不快的现象，如：明明你往<code>Arraylist</code>中存入了<code>String</code>，从中取出时的却是<code>Object</code>，你不得不对返回值进行丑陋的强制类型转换，甚至因错误的转换出现<strong>运行时异常<code>ClassCastException</code></strong>。</p>
<p>以上种种烦恼在今天看来是不可思议的，甚至是荒唐的，这要归功于泛型。</p>
<h2 id="2-泛型是什么，有什么用"><a href="#2-泛型是什么，有什么用" class="headerlink" title="2 泛型是什么，有什么用"></a>2 泛型是什么，有什么用</h2><p>非常简单，泛型就是把对象类型当作参数一样可输入，介绍给编译器，让编译器去考虑它，将上述的问题从运行时“降低”到了编译时，任何程序员都知道，如果程序非要出错不可，编译时错误总好过运行时错误。在IDE的帮助下，甚至不需要等到真正编译的时候就能解决。</p>
<p>泛型的种种“复杂”都是为了确保这份美好愿景而衍生出的状况。</p>
<h2 id="3-泛型不是什么"><a href="#3-泛型不是什么" class="headerlink" title="3 泛型不是什么"></a>3 泛型不是什么</h2><p>谨记泛型只能保持到编译时（其实这个说法不够严谨，在运行时记录并利用泛型信息是可以做到的，Guava和一些序列化类库就这么做了。不过现在不关心反射那方面的事），为了保证它如你所愿的实现，编译器针对泛型做了名为“类型擦除”的一系列工作。</p>
<p>Java的泛型常常被拿来和C++的<code>Template</code>类作比较，C++的<code>Template</code>类会真正的产生不同类型，而在Java中<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>严格地讲并不存在，这两个泛型类的表达依赖与原生的<code>ArrayList&lt;T&gt;</code>间的一种映射关系。</p>
<h2 id="4-类型擦除到底做了些什么"><a href="#4-类型擦除到底做了些什么" class="headerlink" title="4 类型擦除到底做了些什么"></a>4 类型擦除到底做了些什么</h2><p>为了将参数化类型映射到原本的类型，Java编译器进行了类型擦除。经常可以在网上看到像是“Java的泛型只是半吊子，它其实被类型擦除了”这样的说法，这样的说法在某种程度上是有道理的，参数化类型和原生类型的映射关系比起C++的模板类确实显得比较“脆弱”（参数化多态的问题水其实挺深的，对于Java只能期待Project Valhalla早日落成吧）。</p>
<p>类型擦除做了以下工作：</p>
<ol>
<li>将所有类型形参替换成指定的界限，如果没有指定界限则替换为<code>Object</code>。（所以没有像C++模板类实例化时那样真正的许多“参数化类型”存在）</li>
<li>在必要的地方插入强制类型转换，确保类型安全不被破坏。</li>
<li>生成桥接方法，确保多态不被破坏。</li>
</ol>
<p>现在借Oracle官方教程中故意错误使用的实例代码来理解这些工作（有所修改）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = mn;            <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);     </span><br><span class="line">Integer x = mn.data;</span><br></pre></td></tr></table></figure>
<p>使用代码被执行“类型擦除”后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyNode mn = <span class="keyword">new</span> MyNode(<span class="number">5</span>);</span><br><span class="line">Node n = (MyNode)mn;         <span class="comment">// 使用参数化类型的原生形式，编译器抛出unchecked警告</span></span><br><span class="line">n.setData(<span class="string">"Hello"</span>);</span><br><span class="line">Integer x = (String)mn.data;</span><br></pre></td></tr></table></figure>
<p>这样的使用毫无疑问是错误的，即使“参数化类型”并不存在，也不应该把<code>MyNode</code>实例声明为原生的<code>Node</code>类型，只是在继承时声明<code>Node&lt;Integer&gt;</code>是不行的。</p>
<p>异常<code>ClassCastException</code>于<code>n.setData(&quot;Hello&quot;)</code>这一行被抛出，而不是<code>Integer x = (String)mn.data</code>，这好像有点奇怪，<code>MyNode</code>中只有<code>setData(Integer)</code>，可代码确实通过编译并且被运行了，甚至抛出了一个异常。</p>
<p>以下是类被执行类型擦除后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object data)</span> </span>&#123; <span class="keyword">this</span>.data = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Node.setData"</span>);</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyNode</span><span class="params">(Integer data)</span> </span>&#123; <span class="keyword">super</span>(data); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Integer data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyNode.setData"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setData(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有什么不对劲，看似<code>MyNode</code>通过扩展<code>Node&lt;Integer&gt;</code>重写了<code>setData()</code>方法，实际上在类型擦除后，<code>Node</code>和<code>MyNode</code>中却分别出现了两个方法签名并不相同的方法<code>setData(Object)</code>和<code>setData(Integer)</code>，这不是重写（Override）而是重载（Overload），多态似乎被破坏了。为了确保多态，编译器在<code>MyNode</code>中生成了桥接方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">    setData((Integer) data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正完成重写的方法是这个桥接方法，它连接超类方法和“重写方法”以确保多态，现在我们完全清楚地知道了为什么<code>n.setData(&quot;Hello&quot;)</code>可以通过编译并运行，最终还导致了<code>ClassCastException</code>，因为<code>MyNode</code>中确实有相应的方法。</p>
<h2 id="5-泛型的局限"><a href="#5-泛型的局限" class="headerlink" title="5 泛型的局限"></a>5 泛型的局限</h2><p>Oracle的用例非常巧妙，它既可以警示不当用法，还能借此令用户理解泛型。使用参数化类型的原生类型容易导致错误，这种错误是很容易意识到的，但它还有另一些不那么直观的不当用法（再次提一下其他参数化多态，比如，以下这些限制在C#中都是不存在的，而Java的Project Valhalla正试图解决5.1中的问题）。</p>
<h3 id="5-1-基本类型不能作为类型参数"><a href="#5-1-基本类型不能作为类型参数" class="headerlink" title="5.1 基本类型不能作为类型参数"></a>5.1 基本类型不能作为类型参数</h3><p>显然，基本类型不能被赋予声明为<code>Object</code>的变量，注意“字面量类型”和“基本类型”是有区别的，<code>String</code>可以作为参数化类型。解决方法也很简单，使用基本类型对应的包装类：<code>Integer</code>，<code>Long</code>等。但是要谨记，在处理大量数据时自动装箱和拆箱会导致明显的性能问题，JDK中有许多出于此考虑而专门针对基本类型的实现类，而不是简单地仅提供一个泛型类。</p>
<h3 id="5-2-不能用new-T-来创建实例"><a href="#5-2-不能用new-T-来创建实例" class="headerlink" title="5.2 不能用new T()来创建实例"></a>5.2 不能用new T()来创建实例</h3><p><code>Integer integer = new T()</code>在被执行类型擦除后会是<code>Integer integer = new Object()</code>，这肯定行不通。只能对传入的对象使用反射寻找构造器来创建。很不幸，泛型不能帮你省去编写反射代码的痛苦。</p>
<h3 id="5-3-不能用new-T-来创建数组"><a href="#5-3-不能用new-T-来创建数组" class="headerlink" title="5.3 不能用new T[]来创建数组"></a>5.3 不能用new T[]来创建数组</h3><p><code>T[] array = new T[1]</code>实际上是<code>Object[] array = new Object[0]</code>，这样就能放入任何对象，这明显有问题，最终Java决定完全拒绝这么做，用泛型创建数组会抛出编译错误。仍然需要对传入的对象使用反射，具体方法是<code>java.lang.reflect.Array.newInstance()</code>。</p>
<h3 id="5-4-不能创建参数化类型的数组"><a href="#5-4-不能创建参数化类型的数组" class="headerlink" title="5.4 不能创建参数化类型的数组"></a>5.4 不能创建参数化类型的数组</h3><p>类似上一点，这也是彻底不被允许的，<code>new Node&lt;Integer&gt;[1]</code>将不能通过编译。只能使用<code>Collection</code>来存储参数化类型，如<code>ArrayList&lt;Node&lt;Integer&gt;&gt;</code>。</p>
<h3 id="5-5-Varargs警告"><a href="#5-5-Varargs警告" class="headerlink" title="5.5 Varargs警告"></a>5.5 Varargs警告</h3><p>可变参数其实是以数组形式传入的，如果可变参数带有类型参数，就需要创建参数化类型的数组，不同于上一点，Java决定允许这么做，因为最常见的情况是只会从中读取元素，这么做不会有问题，可以放心地打上@SafeVarargs压制警告。但试图往当中添加或修改元素仍然是错误的。</p>
<h3 id="5-6-不能用类型形参进行类型检测和转换"><a href="#5-6-不能用类型形参进行类型检测和转换" class="headerlink" title="5.6 不能用类型形参进行类型检测和转换"></a>5.6 不能用类型形参进行类型检测和转换</h3><p>类似的考虑，Java完全拒绝这种意味不明的做法，<code>obj instanceof Node&lt;Integer&gt;</code>和<code>Node&lt;Integer&gt;obj</code>这样的语句都会抛出编译错误。</p>
<h3 id="5-6-静态字段和方法中不能引用类型变量"><a href="#5-6-静态字段和方法中不能引用类型变量" class="headerlink" title="5.6 静态字段和方法中不能引用类型变量"></a>5.6 静态字段和方法中不能引用类型变量</h3><p><code>static</code>代表着，这是属于类级别的成员，静态字段和静态方法将在所有实例之间共享，不同参数化类型的实例明显不能共享同一份静态成员，因此Java不允许这么做。</p>
<h3 id="5-7-不能捕获和抛出参数化类型的实例"><a href="#5-7-不能捕获和抛出参数化类型的实例" class="headerlink" title="5.7 不能捕获和抛出参数化类型的实例"></a>5.7 不能捕获和抛出参数化类型的实例</h3><p><code>catch (T e)</code>无论如何都是不行的，即使类型参数被声明为<code>T extends Throwable</code>也一样。为什么这样设计似乎有点似是而非，并且据我所知，Oracle官方并没有对此给出过解答，同时似乎也没有什么权威书籍做过什么论断。<strong>因此以下是未经任何认证的个人猜测，至少存在这种情况，如果允许捕获参数化类型的实例，代码会在编译后产生错误顺序的<code>catch</code>子句：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123;<span class="comment">// 如果允许这么做，那么没理由拒绝编译这样的代码</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型擦除后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        method0();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">// 错误，IOExcpetion已被捕获</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数化类型也不能实现<code>Throwable</code>，因为异常可以持有引发自身的另一个异常，允许参数化类型实现<code>Throwable</code>可能导致类似的错误。</p>
<p><strong>请注意</strong>，所谓的抛出是指<code>throw</code>而不是<code>throws</code>，在中文语境中非常容易忽略这一点！后者可以声明适当的类型参数。</p>
<p>用泛型能对异常处理做出一些意想不到的操作，《Java核心技术 卷一》就提到过一种欺骗编译器某个检查型异常是运行时异常的操作，借以突破<code>Runnable</code>接口中的<code>run()</code>方法不允许抛出检查型异常的限制（显然，各种函数式接口也可以被这么做，或者，直接使用Apache Common中的可失败的函数式接口）。</p>
<p>在异常处理中使用泛型很难说有什么优势，却显然会导致混乱，这种做法或许应该彻底避免。</p>
<h3 id="5-8-小心潜在的方法签名冲突"><a href="#5-8-小心潜在的方法签名冲突" class="headerlink" title="5.8 小心潜在的方法签名冲突"></a>5.8 小心潜在的方法签名冲突</h3><p>由于类型擦除会改变方法签名，桥接方法会增加新方法，因此不能编写与之冲突的方法，有时潜在冲突不太明显，比如重写<code>Object</code>中的方法（其中的方法形参很多都是<code>Object</code>类）或复杂的继承情况。</p>
<h2 id="6-通配符，限定，PECS"><a href="#6-通配符，限定，PECS" class="headerlink" title="6 通配符，限定，PECS"></a>6 通配符，限定，PECS</h2><p>这里不会解释什么是不变性，协变性和逆变性，不过仍然需要了解这样的一个事实：</p>
<p><strong><code>List&lt;Integer&gt;</code>不是<code>List&lt;Number&gt;</code>的子类，类似情况皆是如此。</strong></p>
<p>这好像有一点不符合直觉，但其实很有道理。<br>子类继承了超类的所有成员并且能够新增自己的成员，子类的信息量必然大于或等于超类（这个认识也是之前那篇<a href="https://illuminatedworm.github.io/2020/07/21/PECS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E8%AF%BB/" target="_blank" rel="noopener">PECS的一些解读</a>的关键）。可以向<code>List&lt;Number&gt;</code>中放入<code>Long</code>对象，而不能对<code>List&lt;Integer&gt;</code>做这样的事，<code>List&lt;Number&gt;</code>能做的比<code>List&lt;Integer&gt;</code>多，但<strong><code>List&lt;Integer&gt;</code>也不是<code>List&lt;Number&gt;</code>的超类</strong>，这时不能只想着信息量，这里面首先就没有继承关系。</p>
<h3 id="6-1-extends限定"><a href="#6-1-extends限定" class="headerlink" title="6.1 extends限定"></a>6.1 extends限定</h3><p>道理是有了，事却坏了。<code>List&lt;E&gt;</code>有方法<code>addAll(Collection&lt;T&gt;)</code>，但不能向<code>List&lt;Number&gt;</code>中的<code>addAll()</code>方法中传入<code>Collection&lt;Integer&gt;</code>，因为它接受的参数类型现在是<code>Collection&lt;Number&gt;</code>。这显然不对劲。</p>
<p>我们需要<code>addAll()</code>方法的形参类型是“E的<strong><em>所有</em></strong>子类的<code>Collection</code>”，答案就是<code>Collection&lt;? extends T&gt;</code>，现在可以将<code>List&lt;Integer&gt;</code>传入<code>List&lt;Number&gt;</code>的<code>addAll()</code>方法了。</p>
<h3 id="6-2-super限定"><a href="#6-2-super限定" class="headerlink" title="6.2 super限定"></a>6.2 super限定</h3><p>那什么时候又（必须）用得着<code>&lt;? super T&gt;</code>呢，基本上是用在复杂继承时，考虑一个参数，它的抽象概念是“<strong><em>某个</em></strong>实现了针对自身的<code>Comparable</code>接口的类型”，考虑可能它的实参是<code>LocalDate</code>，这个类实现了<code>ChronoLocalDate</code>，而<code>ChronoLocalDate</code>又实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>LocalDate</code>其实实现了<code>Comparable&lt;ChronoLocalDate&gt;</code>，<code>T extends Comparable&lt;T&gt;</code>是不行的，答案是<code>T extends Comparable&lt;? super T&gt;</code>，它的抽象概念是”<strong><em>某个</em></strong>实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口的类型“。</p>
<h3 id="6-3-PECS"><a href="#6-3-PECS" class="headerlink" title="6.3 PECS"></a>6.3 PECS</h3><p>太多的概念，太多复杂的表达，一点也不好运用和记忆。PECS就是为了助记而产生的——记住用处（在理解后）。</p>
<blockquote>
<ul>
<li>T只是产出者（只从中拿出）时，用&lt;? extends T&gt;代替T</li>
<li>T只是消费者（只往里填入）时，用&lt;? super T&gt;代替T</li>
<li>T既是消费者又是产出者，就用T</li>
</ul>
</blockquote>
<p>其实，PECS称得上是原则，几乎总是应该执行这三条规则。</p>
<h3 id="6-1-T，U，R，E，N，K，V和"><a href="#6-1-T，U，R，E，N，K，V和" class="headerlink" title="6.1 T，U，R，E，N，K，V和?"></a>6.1 T，U，R，E，N，K，V和?</h3><p>首先明确，只要是字母，就没有本质区别，不同的字母只是命名约定，出于解释和区分的考虑。可以在同一个作用域中声明多个类型参数，而<code>T</code>，<code>U</code>代表的意思是第一个类型参数和第二个类型参数，<code>T</code>来自Type，而<code>U</code>大概是因为在键盘上离T键近。<code>R</code>通常代表返回值。<code>E</code>代表Element，常见于<code>Collection</code>。<code>N</code>代表数字。<code>K</code>和<code>V</code>代表Key和Value，常见于<code>Map</code>。</p>
<p><code>?</code>则和字母有着真正的区别，在上文中，我用斜体加粗黑字标明了一些形容词，<strong><em>某个</em></strong>和<strong><em>所有</em></strong>形容了它们之间的区别，<code>?</code>并不匹配特定的类型，之所以会用<code>T</code>，是因为会再次用到这个类型，而用<code>?</code>是因为想指代多个，可以说，这两者间其实没有联系……</p>
<p>现在回到开头提到的<code>static &lt;T,U extends Comparable&lt;? super U&gt; Comparator&lt;T&gt; comparing(Function&lt;? super T,? extends U&gt; keyExtractor)</code>，终于能看懂了，它的类型参数列表的抽象概念是，“声明了两个类型参数，一个无限定，一个限定是实现了针对自身及其<strong><em>所有</em></strong>超类的<code>Comparable</code>接口”，而形参类型也符合PECS——<code>Function</code>函数式接口接受一个值（消费者），返回一个值（产出者）。</p>
<p>无限定的<code>?</code>在类型擦除时会彻底消失，连<code>Object</code>也不会留下，所以使用无限定的<code>?</code>会很奇怪，考虑<code>setFoo(?)</code>和<code>? getFoo()</code>，前者究竟可以传入什么呢？答案是除了<code>null</code>什么都不能传入。至于后者，针对一个毕竟可能真实存在的对象，Java不能粗暴地当返回值是<code>void</code>处理，也不能返回给你一个“什么都不是”的东西，所以只好返回作为终极超类的<code>Object</code>类型。</p>
<h2 id="7-部分术语中英文对照"><a href="#7-部分术语中英文对照" class="headerlink" title="7 部分术语中英文对照"></a>7 部分术语中英文对照</h2><p>特别标明一下以下几个术语，我发现不少地方错误地把泛型接口称为泛型类，把参数化类型与类型变量或类型参数（实参/形参）搞混。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">中文</th>
<th style="text-align:center">英文</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">泛型类</td>
<td style="text-align:center">Generic class</td>
<td style="text-align:center">声明了类型变量的类</td>
</tr>
<tr>
<td style="text-align:center">泛型接口</td>
<td style="text-align:center">Generic Interface</td>
<td style="text-align:center">声明了类型变量的接口</td>
</tr>
<tr>
<td style="text-align:center">参数化类型</td>
<td style="text-align:center">Parameterized type</td>
<td style="text-align:center">指代泛型类或有类型形参的泛型接口</td>
</tr>
<tr>
<td style="text-align:center">类型变量</td>
<td style="text-align:center">Type variable</td>
<td style="text-align:center">不那么严格的表达，来自类，接口，方法和构造器中的类型实参的声明</td>
</tr>
<tr>
<td style="text-align:center">类型形参</td>
<td style="text-align:center">Type parameter</td>
<td style="text-align:center">类比于形参</td>
</tr>
<tr>
<td style="text-align:center">类型实参</td>
<td style="text-align:center">Type argument</td>
<td style="text-align:center">类比于实参</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/%E7%94%A8JMH%E6%B5%8B%E8%AF%95FastClass%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">用JMH测试FastClass和反射的效率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-13 16:07:41 / 修改时间：21:50:03" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:41+08:00">2020-09-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>现在来验证一下在Inflation优化下，Java反射和CGLib的<code>FastClass</code>哪个更高效。所用测试参数，JDK，JMH和JVM详情见输出结果。</p>
<h2 id="2-测试代码和输出结果"><a href="#2-测试代码和输出结果" class="headerlink" title="2 测试代码和输出结果"></a>2 测试代码和输出结果</h2><p>省略Bean类代码</p>
<p><code>FastClass</code>实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastClass;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.reflect.FastMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastClassImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FastClass fastClass = FastClass.create(TestBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastClassImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class[] noParam = <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">        FastMethod getA = fastClass.getMethod(<span class="string">"getA"</span>, noParam);</span><br><span class="line">        FastMethod getB = fastClass.getMethod(<span class="string">"getB"</span>, noParam);</span><br><span class="line">        FastMethod getC = fastClass.getMethod(<span class="string">"getC"</span>, noParam);</span><br><span class="line">        FastMethod getD = fastClass.getMethod(<span class="string">"getD"</span>, noParam);</span><br><span class="line">        FastMethod setA = fastClass.getMethod(<span class="string">"setA"</span>, <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setB = fastClass.getMethod(<span class="string">"setB"</span>, <span class="keyword">new</span> Class[]&#123;Integer<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setC = fastClass.getMethod(<span class="string">"setC"</span>, <span class="keyword">new</span> Class[]&#123;Double<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line">        FastMethod setD = fastClass.getMethod(<span class="string">"setD"</span>, <span class="keyword">new</span> Class[]&#123;LocalDateTime<span class="class">.<span class="keyword">class</span>&#125;)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj, noParam);</span><br><span class="line">        Object b = getB.invoke(originalObj, noParam);</span><br><span class="line">        Object c = getC.invoke(originalObj, noParam);</span><br><span class="line">        Object d = getD.invoke(originalObj, noParam);</span><br><span class="line"></span><br><span class="line">        Object clone = fastClass.newInstance();</span><br><span class="line">        setA.invoke(clone, <span class="keyword">new</span> Object[]&#123;a&#125;);</span><br><span class="line">        setB.invoke(clone, <span class="keyword">new</span> Object[]&#123;b&#125;);</span><br><span class="line">        setC.invoke(clone, <span class="keyword">new</span> Object[]&#123;c&#125;);</span><br><span class="line">        setD.invoke(clone, <span class="keyword">new</span> Object[]&#123;d&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>反射实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReflectionImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">clone</span><span class="params">(T originalObj)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; oClass = originalObj.getClass();</span><br><span class="line"></span><br><span class="line">        Method getA = oClass.getMethod(<span class="string">"getA"</span>);</span><br><span class="line">        Method getB = oClass.getMethod(<span class="string">"getB"</span>);</span><br><span class="line">        Method getC = oClass.getMethod(<span class="string">"getC"</span>);</span><br><span class="line">        Method getD = oClass.getMethod(<span class="string">"getD"</span>);</span><br><span class="line">        Method setA = oClass.getMethod(<span class="string">"setA"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setB = oClass.getMethod(<span class="string">"setB"</span>, Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setC = oClass.getMethod(<span class="string">"setC"</span>, Double<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method setD = oClass.getMethod(<span class="string">"setD"</span>, LocalDateTime<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        Object a = getA.invoke(originalObj);</span><br><span class="line">        Object b = getB.invoke(originalObj);</span><br><span class="line">        Object c = getC.invoke(originalObj);</span><br><span class="line">        Object d = getD.invoke(originalObj);</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; constructor = oClass.getConstructor();</span><br><span class="line">        Object clone = constructor.newInstance();</span><br><span class="line">        setA.invoke(clone, a);</span><br><span class="line">        setB.invoke(clone, b);</span><br><span class="line">        setC.invoke(clone, c);</span><br><span class="line">        setD.invoke(clone, d);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ((T) clone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        TestBean a = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line">        TestBean clone = clone(a);</span><br><span class="line">        System.out.println(a == clone);</span><br><span class="line">        System.out.println(a.equals(clone));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>false</p>
<p>true</p>
</blockquote>
<p>基准性能测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.AverageTime)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">4</span>)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.NANOSECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestBean TEST_BEAN = <span class="keyword">new</span> TestBean(<span class="string">"a"</span>, <span class="number">50</span>, <span class="number">100</span>D, LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cglib</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FastClassImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reflection</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ReflectionImpl.clone(TEST_BEAN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(Test<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果（部分）：</p>
<blockquote>
<p>JMH version: 1.25.2</p>
<p>VM version: JDK 1.8.0_251, Java HotSpot(TM) 64-Bit Server VM, 25.251-b08</p>
<p>Benchmark        Mode  Cnt     Score     Error  Units<br>Test.cglib       avgt    5  3614.397 ± 115.349  ns/op<br>Test.reflection  avgt    5  1502.978 ±  84.247  ns/op</p>
</blockquote>
<p>反射完胜。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/CGLib%E4%B9%8BEnhancer%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">CGLib之Enhancer小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:07:03" itemprop="dateCreated datePublished" datetime="2020-09-13T16:07:03+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 23:23:40" itemprop="dateModified" datetime="2020-10-09T23:23:40+08:00">2020-10-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>参考资料：<a href="https://dzone.com/articles/cglib-missing-manual" target="_blank" rel="noopener">CGLib: The Missing Menual</a></p>
<h2 id="1-不要用非静态内部类创建Callback或者保存其为静态变量"><a href="#1-不要用非静态内部类创建Callback或者保存其为静态变量" class="headerlink" title="1 不要用非静态内部类创建Callback或者保存其为静态变量"></a>1 不要用非静态内部类创建Callback或者保存其为静态变量</h2><p>许多国内博客明显也参考了这份资料，然而他们都忽略了一个资料作者提及的重要事项：出于CGLib的实现原理，在创建<code>Enhancer</code>的类中使用匿名内部类创建<code>Callback</code>是危险的。资料作者使用匿名内部类只是为了简化演示代码。</p>
<p><strong>静态字段可以成为所谓的GC Root</strong>。</p>
<p><code>Enhancer</code>对象会为它的每个<code>Callback</code>创建一个私有的，静态的字段，而<code>Callback</code>本身在工作时，也会根据情况在<code>Enhancer</code>对象中加入静态字段。如果以匿名内部类创建<code>Callback</code>实例，由于非静态匿名内部类隐式地包含对外部类实例的引用，这会造成外部类实例，<code>Enhancer</code>对象和<code>Callback</code>对象之间交错的相互引用，静态字段加上循环引用非常容易妨碍到GC回收，这种情况下<code>Callback</code>对象<strong>永远</strong>不会被回收，这对于内存管理来说非常危险。</p>
<p>在CGLib的使用中用匿名内部类实现<code>Callback</code>的诱惑，相比在JDK动态中使用匿名内部类实现<code>InvocationHandler</code>更大，<code>InvocationHandler</code>通常需要包装被代理实例作为字段，在匿名内部类里做这一点显得非常冗长，而CGLib的代理对象是被代理对象的子类，能通过在<code>create()</code>方法中传入构造器形参类型和实参构造出完全代理被代理对象的实例。</p>
<p>普通的成员内部类也隐式地包含对外部类实例的引用，因此和非静态匿名内部类有同样的危险，但成员内部类的引用容易获得，至少能够管理（虽然这么做会非常麻烦且毫无道理），而匿名内部类则不能。</p>
<p>如果要用匿名内部类实现<code>Callback</code>，需要小心分辨。另外注意，Lambda表达式的实现也用到了非静态匿名内部类，所以也存在上述风险。</p>
<h2 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2 测试代码"></a>2 测试代码</h2><p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal0</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal0 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Calculator cal1 "</span> + name +</span><br><span class="line">                <span class="string">"\nplus: "</span> + add(a, b) +</span><br><span class="line">                <span class="string">"\nminus: "</span> + minus(a, b) +</span><br><span class="line">                <span class="string">"\ntimes: "</span> + times(a, b) +</span><br><span class="line">                <span class="string">"\ndivided: "</span> + divided(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">times</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">divided</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CallBack</code>实现类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Author: Illuminated Worm</span><br><span class="line"> * Version: 1.00</span><br><span class="line"> * Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CallBackDemo implements MethodInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; objects.length; i++) &#123;</span><br><span class="line">            objects[i] &#x3D; (Integer) objects[i] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return methodProxy.invokeSuper(o, objects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.Calculator;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.cglibdemo.CallBackDemo;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.CallbackHelper;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.NoOp;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Author: Illuminated Worm</span></span><br><span class="line"><span class="comment"> * Version: 1.00</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer b = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Calculator calculator = <span class="keyword">new</span> Calculator(<span class="string">"raw"</span>);</span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unit0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Calculator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        CallbackHelper callbackHelper = new CallbackHelper(Calculator.class, new Class[0]) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">getCallback</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"cal1"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> NoOp.INSTANCE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> CallBackDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        enhancer.setCallbackFilter(callbackHelper);</span><br><span class="line">        enhancer.setCallbacks(callbackHelper.getCallbacks());</span><br><span class="line"></span><br><span class="line">        Class[] argsType = &#123;String<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">        String[] arguments = &#123;<span class="string">"Proxy"</span>&#125;;</span><br><span class="line">        Calculator calculator = (Calculator) enhancer.create(argsType, arguments);</span><br><span class="line"></span><br><span class="line">        calculator.cal0(a, b);</span><br><span class="line">        calculator.cal1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Calculator cal0 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0<br>Calculator cal1 raw<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
<p>Calculator cal0 Proxy<br>plus: 12<br>minus: -4<br>times: 32<br>divided: 0<br>Calculator cal1 Proxy<br>plus: 10<br>minus: -4<br>times: 21<br>divided: 0</p>
</blockquote>
<h2 id="3-流程小结，Callback类鉴别"><a href="#3-流程小结，Callback类鉴别" class="headerlink" title="3 流程小结，Callback类鉴别"></a>3 流程小结，Callback类鉴别</h2><p>现在根据使用流程逐个总结使用细节。</p>
<p>在创建<code>Enhancer</code>对象后一定要使用<code>setSuperClass()</code>方法传入被代理类的类对象，即使<code>CallbackHelper</code>看起来也传入了被代理类的类对象，它不会为你完成这一步。</p>
<p><code>CallbackHelper</code>是<code>CallbackFilter</code>的默认实现类，设置过滤器的主要目的是将方法调用分发和具体的方法实现解耦，在这里做的工作基本就是根据方法名称调用不同的<code>Callback</code>。</p>
<p>使用<code>CallbackHelper</code>的情况下可以更简洁地为<code>Enhancer</code>设置<code>Callback</code>。如果不打算解耦分发逻辑和方法实现的话，或者分发逻辑较简单可以并入<code>Callback</code>，那么<code>CallbackHelper</code>并非必须的。</p>
<p><code>Callback</code>有如下几种：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">详情</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FixedValue</td>
<td style="text-align:center">简单地用另一个对象（通常是固定的）代替原本的返回值</td>
</tr>
<tr>
<td style="text-align:center">InvocationHandler</td>
<td style="text-align:center">大致与JDK动态代理用的InvocationHandler一样</td>
</tr>
<tr>
<td style="text-align:center">MethodInterceptor</td>
<td style="text-align:center">最全面，相比InvocationHandler多了一个MethodProxy类型的参数</td>
</tr>
<tr>
<td style="text-align:center">LazyLoader</td>
<td style="text-align:center">FixedValue的懒加载版，用于返回昂贵的对象</td>
</tr>
<tr>
<td style="text-align:center">Dispatcher</td>
<td style="text-align:center">每次方法调用都会重新生成返回对象，用于不改变对类的引用而改变其实现时</td>
</tr>
<tr>
<td style="text-align:center">ProxyRefDispatcher</td>
<td style="text-align:center">用于调用类的另一个方法</td>
</tr>
<tr>
<td style="text-align:center">NoOp</td>
<td style="text-align:center">使用被代理类原本的方法</td>
</tr>
</tbody>
</table>
</div>
<p><code>ProxyRefDispatcher</code>和<code>NoOp</code>基本上是用在解耦后的分发逻辑里的。<code>MethodInterceptor</code>虽然全面，但其他<code>Callback</code>更高效。</p>
<p><code>MethodInterceptor</code>提供的<code>MehtodProxy</code>对象有<code>invoke()</code>和<code>invokeSuper()</code>两个方法，前者用于对<strong>别的对象</strong>调用方法，后者才是对当前对象调用父类（被代理类）的方法。如果对当前对象使用<code>invoke()</code>将会导致死循环！</p>
<p>上文也提到过，CGLib的代理类是被代理类的子类，能轻易地完全摆脱被代理类实例，这可以在调用<code>create()</code>方法时完成。JDK动态代理不便于也不适宜完全取代被代理类实例。</p>
<p><code>Enhancer</code>作为CGLib中的重要使用对象，其API还是比较清晰明白的。CGLib适合于对未实现接口的类进行动态代理，但它创建新类的速度并没有JDK动态代理快，因此在Spring这种有数量不多的单例对象的情景里，只要目标实现了接口，Spring就选择Java原生代理。并且CGLib的动态代理的功能并非完全覆盖JDK动态代理——出于继承机制的限制，CGLib动态代理不能作用于<code>final</code>方法。</p>
<p>CGLib的<code>FastClass</code>通过直接对生成字节码来做到比反射更快。反射的底层是基于C语言的原生方法，其效率固然不那么快，然而HotSpot这样的现代JVM中有着inflation优化机制：反射JNI调用超过一定次数（默认为15）后，便会生成本地的字节码。在这种情况下，反射的效率劣势得到了一定程度的弥补，所以CGLib的<code>FastClass</code>也不是那么推荐了。悲伤的故事^ ^。</p>
<p>CGLib的主要问题在于，它会生成许多新类，消耗堆空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/13/SpringAOP%E5%B0%8F%E8%AF%95/" class="post-title-link" itemprop="url">SpringAOP小试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-13 16:06:30" itemprop="dateCreated datePublished" datetime="2020-09-13T16:06:30+08:00">2020-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-25 15:08:13" itemprop="dateModified" datetime="2020-10-25T15:08:13+08:00">2020-10-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-测试代码"><a href="#1-测试代码" class="headerlink" title="1 测试代码"></a>1 测试代码</h2><p>导入jar包省略。</p>
<p>Spring已配置包扫描，加入aspectj支持：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>“DAO”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDaoImpl</span> <span class="keyword">implements</span> <span class="title">TestDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Your input: "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“Service”层代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.annotation.WormCut;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDao;</span><br><span class="line"><span class="keyword">import</span> com.illuminatedworm.dao.TestDaoImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TestDao testDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTestDao</span><span class="params">(TestDaoImpl testDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testDao = testDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m0 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@WormCut</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method m1 triggered."</span>);</span><br><span class="line">        testDao.sayHello(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WormCut &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Aspect：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javasm.service.TestServiceImpl.m0(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.javasm.annotation.WormCut)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Execution of method "</span> + pjp.getSignature().getName() + <span class="string">" took "</span> + (end - start) + <span class="string">"ms."</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeAdvice</span><span class="params">(JoinPoint jp)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Before advice triggered."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"JoinPoint kind: "</span> + jp.getKind());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Method signature: "</span> + jp.getSignature().getName());</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"Args: "</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object arg : jp.getArgs()) &#123;</span><br><span class="line">            System.out.print(arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Target object hashcode: "</span> + jp.getTarget().hashCode());</span><br><span class="line">        System.out.println(<span class="string">"Proxy object hashcode: "</span> + jp.getThis().hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(jp.getStaticPart().toLongString());</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(pointcut = <span class="string">"cut0()"</span>, returning = <span class="string">"obj"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturningAdvice</span><span class="params">(JoinPoint jp, Object obj)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterReturning advice triggered."</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"There is no returning Obj."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"cut0()"</span>, throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwAdvice</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"AfterThrowing advice triggered."</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"cut0()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"After advice triggered."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cut1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationBeforeAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"Annotation pointcut success."</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.illuminatedworm.service.TestService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.00</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">init</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        TestService testService = applicationContext.getBean(TestService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        testService.m0(<span class="string">"Hello Spring!"</span>);</span><br><span class="line">        testService.m1(<span class="string">"Hello Annotation!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Before advice triggered.<br>JoinPoint kind: method-execution<br>Method signature: m0<br>Args: Hello Spring!<br>Target object hashcode: 790094605<br>Proxy object hashcode: -1294849058<br>execution(public abstract void com.javasm.service.TestService.m0(java.lang.String))</p>
<p>method m0 triggered.<br>Your input: Hello Spring!</p>
<p>AfterReturning advice triggered.<br>There is no returning Obj.</p>
<p>After advice triggered.</p>
<p>Execution of method m0 took 1007ms.</p>
<p>Annotation pointcut success.</p>
<p>method m1 triggered.<br>Your input: Hello Annotation!</p>
</blockquote>
<h2 id="2-流程小结，通知注释鉴别"><a href="#2-流程小结，通知注释鉴别" class="headerlink" title="2 流程小结，通知注释鉴别"></a>2 流程小结，通知注释鉴别</h2><p>将Contoller，Service和DAO等关键对象交给Spring管理，对于使用者来说，从亲手实现代理和在各处用代理对象替换被代理对象中解放出来，控制反转让施行真正的面向切面编程成为现实。（要注意的是SpringAOP采用的这种实现方式并不是唯一的，如AspectJ本身是在编译时通过专用编译器生成字节码来实现的）</p>
<p>需要声明切面，创建一个类，注释以<code>Aspect</code>并将其注入Spring。</p>
<p>然后建立空方法，以<code>@Pointcut</code>注释来声明需要切入处，主要方式有：</p>
<ol>
<li><p>execution方式，大致格式为“[返回值类型]空格[包|类|方法的全限定名]（形参类型）”。其中返回值和全限定名都可以以*作为通配符，形参类型可以写作“..”以省略。</p>
</li>
<li><p>@annotation方式，将定位反转，通过切入处的指定注释来找到切入处，注释必须用全限定名。</p>
</li>
</ol>
<p>最后建立方法，声明通知时机，通知时机的选择可见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">注释</th>
<th style="text-align:center">调用时机</th>
<th style="text-align:center">注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@Before</td>
<td style="text-align:center">切入方法调用前</td>
<td style="text-align:center">可以从JoinPoint中获得除了切入方法返回值外的多数信息</td>
</tr>
<tr>
<td style="text-align:center">@AfterReturning</td>
<td style="text-align:center">切入方法返回后</td>
<td style="text-align:center">在注释中赋值returning，可以获得切入方法返回值</td>
</tr>
<tr>
<td style="text-align:center">@AfterThrowing</td>
<td style="text-align:center">切入方法抛出异常后</td>
<td style="text-align:center">在注释中赋值throwing，可以获得切入方法抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">@After</td>
<td style="text-align:center">切入方法完成后</td>
<td style="text-align:center">不能获得什么信息</td>
</tr>
<tr>
<td style="text-align:center">@Around</td>
<td style="text-align:center">囊括以上</td>
<td style="text-align:center">最强大的通知，可以以ProceedingJoinPoint的proceed()方法划分切入方法执行前后。</td>
</tr>
</tbody>
</table>
</div>
<p>通过给@Around注释的方法中的<code>proceedingJoinPoint.proceed()</code>语句围绕try-catch-finally代码块，@Aroud注释的方法就能囊括所有其他调用时机。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="IlluminatedWorm">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IlluminatedWorm's Blog">
    </span>

    
    
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">从Mybatis看动态代理和设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-08 01:04:01" itemprop="dateCreated datePublished" datetime="2020-09-08T01:04:01+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-14 22:48:36" itemprop="dateModified" datetime="2020-09-14T22:48:36+08:00">2020-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文基于JDK 1.8.0_261，Mybatis 3.5.5。</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><ol>
<li>接口规定方法，具体的实现类继承（inherit）接口，实现方法。这个过程就像某人签署了一份有要求的协议，遵守了某种约定。</li>
<li>向上转型，实例化子类对象，将其声明为超类类型。在Java中接口不能被实例化，但可以在向上转型时用作声明。</li>
<li>Java的反射机制赋予程序员在运行时分析和操作类的能力。</li>
</ol>
<p>像这样的基础知识在初学时都会感觉有些不知所云，它们过于抽象，即使能完全理解其字面，也会因为缺乏对实际运用情景的了解而体会浅显。</p>
<p>许多东西就像各种专业工具，它叫什么和包含了什么概念并不是首要的，首要的是它能做什么，某些情况下知道它不能做什么也非常重要。</p>
<p>反射机制尚可联想出一些具有通用性的简单工具类来加以实践，而类似1，2点则彻底令人一头雾水，这是因为它们的概念和实现往往都和设计模式有关。Mybatis正是运用到了相关的设计模式，它毫无疑问是一个具体，有效，好用的工具——它实现了这样的目的：以更标准（以DTD模板和库内十分硬编码的解析方式约束配置文件写法）和更便捷的方式处理持久化层代码（可能需要搭配第三方工具和插件）。借由理解这个工具的原理，可以解惑。但在此之前先复习一下动态代理。</p>
<h2 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h2><p>假设现在存在这样的需求：有相当数目的遗留代码，现在需要对其中的方法附加新功能，而你被要求不能改动遗留代码（更可能的是你自己就不想干牵一发而动全身的恐怖事情）。那么你需要的就是所谓的“非侵入式代码”，具体的做法是，写一个新的类，将旧类作为成员变量包进来，在新类的方法中调用旧类的方法并附加你的新功能。十分易懂。专门自己完全手写这样的类就是所谓的静态代理。</p>
<p>动态代理和静态代理的本质都一样，所谓的动态就是通过找到一种既定的模式，让程序自己处理方法调用那一步，这样面对几十个类就不需要写几十个代理类了，而这份“既定的模式”就依赖接口来达成，程序通过接口来得知有哪些方法，<strong>Java原生动态代理</strong>的前提就是，<strong>被代理的类应该有其接口</strong>。</p>
<h3 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h3><p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Interface of simple calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Impelement of simple calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: the hanlder for calculator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorHanlder</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalculatorHanlder</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        StringBuilder strBuilder = <span class="keyword">new</span> StringBuilder(<span class="string">"Now we intercept method "</span>);</span><br><span class="line">        strBuilder.append(method.getName()).append(<span class="string">"("</span>);</span><br><span class="line">        String prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (Parameter parameter : method.getParameters()) &#123;</span><br><span class="line">            strBuilder.append(prefix);</span><br><span class="line">            prefix = <span class="string">", "</span>;</span><br><span class="line">            strBuilder.append(parameter.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        strBuilder.append(<span class="string">"), parameters = ["</span>);</span><br><span class="line">        prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            strBuilder.append(prefix);</span><br><span class="line">            prefix = <span class="string">", "</span>;</span><br><span class="line">            strBuilder.append(arg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        strBuilder.append(<span class="string">"], we are able to do things as we wish."</span>);</span><br><span class="line">        System.out.println(strBuilder.toString());</span><br><span class="line">        Integer result = (Integer) method.invoke(target, args) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * author: illuminated worm</span></span><br><span class="line"><span class="comment"> * version: 1.0</span></span><br><span class="line"><span class="comment"> * description: Let's check out.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result of 3 + 7 ?"</span>);</span><br><span class="line">        CalculatorImpl calculator = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">        <span class="keyword">int</span> result0 = calculator.add(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"result without proxy: "</span> + result0);</span><br><span class="line"></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class[]&#123;Calculator<span class="class">.<span class="keyword">class</span>&#125;,</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">CalculatorHanlder</span>(<span class="title">calculator</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = ((Calculator) proxy).add(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">"result with proxy: "</span> + result1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>result of 3 + 7 ?<br>result without proxy: 10<br>Now we intercept method add(int arg0, int arg1), parameters = [3, 7], we are able to do things as we wish.<br>result with proxy: 11</p>
</blockquote>
<h3 id="2-2-就是这样"><a href="#2-2-就是这样" class="headerlink" title="2.2 就是这样"></a>2.2 就是这样</h3><p>如上所见，对代理对象调用方法时，它就会“拦截”到这份调用，把代理对象，被调用方法和参数都呈递出来。在这里，我用反射分析并输出了“拦截”到的方法的签名，还为其计算结果增加了1，可以做的事情十分自由，尤其是知道被代理类的具体情况，可以根据方法名“拦截”特定方法而对其他方法“放行”，可以判断对参数的强制类型转换是否安全。至于代理对象，典型的场景是代理对象存储在集合内，对集合的操作都是对代理对象的操作，你会想要处理代理对象而不是被代理对象。</p>
<p><code>Proxy</code>实例加上处理器就是静态代理中代理类的等价物，只是凭借接口的约定，达到了美妙的编程体验（当然可能也增加了一些反射机制的常见苦恼，通用性是有代价的），并没有什么魔法。</p>
<p>在调试中可以看到proxy实例的类型是<code>$Proxy0</code>，可以让JVM保留它的类文件。在我这里是这样做的，在程序开头加入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
<p>或设置JVM参数“-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true”。注意，<code>ProxyGenerator</code>在不同的JDK版本中可能位于不同的包下。</p>
<p>反编译$Proxy0.class能直观地明白为什么动态代理只能依赖接口而不是类，因为$Proxy0已经扩展了<code>Proxy</code>。并且可以看出这个类的目的，非常简单而贴心，它巨细无遗地为你拦截了传入接口中的方法（包括继承而来的方法），把参数传入给处理器的<code>invoke()</code>方法，并对返回值进行强制类型转换。从这些重复工作中解脱出来正是使用动态代理的魅力。</p>
<p>如果只是这样，感觉动态代理类似乎也并不是那么有用，那么可以通过Mybatis的Mapper再来体会一下。</p>
<h2 id="3-Mybatis"><a href="#3-Mybatis" class="headerlink" title="3 Mybatis"></a>3 Mybatis</h2><p>在进入<code>getMapper()</code>方法之前，有必要简单领略一下Mybatis的整个流程，只是从较高的抽象层次讲述，不会从源代码中一条一条的分析。典型的使用流程如下图：</p>
<img src="/2020/09/08/%E4%BB%8EMybatis%E7%9C%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Mybatis%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.png" class="">
<ol>
<li>以mybatis-config.xml文件创建流。</li>
<li>创建<code>SqlSessionFactoryBuilder</code>实例，调用用它的<code>builder()</code>，将上面的输入流传入，获取<code>SqlSessionFactory</code>对象。</li>
<li>调用<code>SqlSessionFactory</code>实例的<code>openSession()</code>方法获取<code>SqlSession</code>对象。</li>
<li>调用<code>SqlSession</code>实例的<code>getMapper()</code>方法，将某个DAO层接口的<code>Class</code>对象传入，获取代理对象。</li>
</ol>
<p>这个流程乍看起来似乎很麻烦，为什么要分割成这么多步呢？有很多理由支持这样的做法。</p>
<h3 id="3-1-应该快速死亡的SqlSessionFactoryBuilder"><a href="#3-1-应该快速死亡的SqlSessionFactoryBuilder" class="headerlink" title="3.1 应该快速死亡的SqlSessionFactoryBuilder"></a>3.1 应该快速死亡的SqlSessionFactoryBuilder</h3><p>如流程图所示，<code>SqlSessionFactoryBuilder</code>实例的唯一目的是创建出一个<code>Configuration</code>类型的实例，<code>Configuration</code>对象可以认为是对mybatis-config.xml的映射，如果你查看源代码，就会发现这个类整整有50个字段！并且某些字段还是包含更多数据的集合！</p>
<p>如此多的字段需要装填，这些数据还需要颇为麻烦的XML文本解析——嵌套的标签，判错，赋予缺省值……因此Mybatis的实现者对此采用了构建器模式，即便如此，代码层层往下看起来仍然十分麻烦，为普通JavaBean类编写的构建器与之相比可是说是小巫见大巫了。不过我们现在并不关心类库程序员的烦心事。</p>
<p>作为用户，我们应该想到的是，解析文本从来都是一件麻烦事，除了具体实现，还有这些实现所占用的资源。严格地讲，解析mybatis-config.xml所用的是一个有限状态机，它颇为昂贵，而解析得到的<code>Configuration</code>相比之下不过是更单纯的一系列数据结构。合情合理地，解析资源应该被尽快释放。</p>
<h3 id="3-2-我只是要发起会话而已……SqlSessionFactory"><a href="#3-2-我只是要发起会话而已……SqlSessionFactory" class="headerlink" title="3.2 我只是要发起会话而已……SqlSessionFactory"></a>3.2 我只是要发起会话而已……SqlSessionFactory</h3><p>从源代码来看，<code>SqlSessionFactory</code>不过包装着仅有的一个<code>Configuration</code>对象，有数个私有的较复杂方法和一系列公开的<code>openSession()</code>方法的简单重载，然而这就是工厂模式的简单形式。大多数时候，用户只是想要简单地想要一个<code>SqlSession</code>罢了，并不想填写那些可选参数。于是这个工作被交由几个公开方法承担，它们填写符合直觉与约定的缺省值（例如，对于SQL语句是否自动提交，你并不想每次都去填写一个布尔值），调用那些看起来就麻烦的私有方法，将结果传递给用户。</p>
<p>从用户体验来看，这个设计模式的效果是良好的。</p>
<p><code>SqlSessionFactory</code>中包含得来不易的那个<code>Configration</code>对象，应该把它做成单例模式里的常量反复使用，当然这在Spring框架里这是不需要自己实现的。</p>
<p><code>SqlSessionFactoryBuilder</code>对象在完成它的任务后不再被引用，最终将被GC回收掉，<code>SqlSessionFactory</code>对象作为枚举实例的字段保留下来。一切正如Mybatis官方建议的那样。</p>
<h3 id="3-3-不是Connection而是SqlSession"><a href="#3-3-不是Connection而是SqlSession" class="headerlink" title="3.3 不是Connection而是SqlSession"></a>3.3 不是Connection而是SqlSession</h3><p><code>SqlSession</code>对象看起来像是<code>Connection</code>和<code>&lt;T extends Statement&gt;</code>的综合，可以向它传入Sql语句和参数，它与数据库连接并执行Sql语句。它的名字容易让人想到Web中的Session，Session是计算机科学的一个基本概念，而<code>SqlSession</code>和Web中的Session都可以看作此概念在特定领域的实现。</p>
<p>值得一提的是Mybatis自带了数据库连接池的实现，当<code>SqlSession</code>对象调用<code>close()</code>方法时，追踪看下去似乎就是对应的<code>Connection</code>对象调用<code>close()</code>方法，但其实这里仍然用到了代理模式，这份调用最终会被<code>PooledConnection</code>“拦截”，将连接放回连接池而不是真正的关闭它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//... 省略</span></span><br><span class="line">        <span class="keyword">this</span>.proxyConnection = (Connection)Proxy.newProxyInstance(Connection<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">IFACES</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"close"</span>.equals(methodName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">                    <span class="keyword">this</span>.checkConnection();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.realConnection, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PooledConnection</code>中有一个比较令人迷惑的做法，它实现了<code>InvocationHandler</code>，那么理所当然它只是处理器而已，但实现者似乎是为了方便，在这个类的构造器中就用当前实例创建了动态代理实例，也就是说，<code>PooledConnection</code>的实例包含了一个与自身互相引用的字段。在Mybatis中的其他处理器类中没有采用这种做法，</p>
<p>总之，这种做法也许不失为将<code>Proxy</code>实例和处理器一体化的可行做法。</p>
<h3 id="3-4-getMapper"><a href="#3-4-getMapper" class="headerlink" title="3.4 getMapper()"></a>3.4 getMapper()</h3><p>对<code>SqlSessionFactory</code>的<code>getMapper()</code>方法往下追踪，可以在<code>MapperRegistry</code>类中发现如下代码（省略了大部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="keyword">this</span>.knownMappers.get(type);</span><br><span class="line">        <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + var5, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>KnownMappers是解析XML配置文件得来的<code>HashMap</code>，其键来自mapper配置里的namespace，即用户配置的接口，通过<code>getMapper()</code>方法传入的<code>Class</code>对象来匹配并获得对应的代理工厂。</p>
<p>我们最终可以在<code>MapperProxy</code>中找到关键的方法调用，它进行了许多小心翼翼的判断，传入的类是否为<code>Object</code>，调用的方法是否为默认方法（有方法体的接口方法），针对性进行各自适宜的处理，最终，它用接口名和方法名去<code>Configuration</code>中匹配找到解析语句标签得到的相关对象，用以生成Sql语句并调用<code>SqlSession</code>中的对应方法执行。</p>
<h2 id="4-不限于斯，第三方动态代理"><a href="#4-不限于斯，第三方动态代理" class="headerlink" title="4 不限于斯，第三方动态代理"></a>4 不限于斯，第三方动态代理</h2><p>就像之前提到的，Java原生动态代理需要一个前提，被代理类实现了某个接口。可是为Bean类提供接口并不是普遍的做法，那么Mybatis如何动态生成和填充相应的Bean对象呢，如果使用反射，那么要做的工作是：查找Bean类的无参构造器，改变其可访问性，查找字段，根据字段名查找Setter方法，改变其可访问性，构造实例，调用Setter方法……</p>
<p>我们会发现，即时忽略需要接口的前置条件，Java原生代理似乎对于当前的需求仍不太适宜：Java原生动态代理可以很快地生成新类，可是反射虽然说不上慢，却也不快，反射所须的上述一系列“周全”的工作拖慢了后续执行。为此，Mybatis中用了第三方工具CGLib来解决对Bean类代理问题，CGLib是基于继承机制和第三方ASM框架的，ASM框架加载被代理类的字节码文件，加以修改生成子类，靠更快的后续执行胜过反射。</p>
<p><strong>至少，曾经是这样的，现在则不一定。</strong>认为Java的反射效率低其实是历史遗留色彩很重的观点，在现在的许多性能基准测试中，在执行次数大的前提下，反射与第三方代替类库的效率相差无几。</p>
<p>原生工具和第三方工具并没有什么优劣之别，只是侧重点不同。此消彼长，客观规律罢了，实际应用中的重点在于选择。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IlluminatedWorm</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

      








    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  















  

  

  

</body>
</html>
